   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB103:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode) { return false; }
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #    endif
 102:tmk_core/common/action.c **** #endif
 103:tmk_core/common/action.c **** 
 104:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 105:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 105 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 105 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 105 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 106:tmk_core/common/action.c **** #else
 107:tmk_core/common/action.c ****     process_record(&record);
 108:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 109:tmk_core/common/action.c ****         dprint("processed: ");
 110:tmk_core/common/action.c ****         debug_record(record);
 111:tmk_core/common/action.c ****         dprintln();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #endif
 114:tmk_core/common/action.c **** }
  76               		.loc 1 114 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 105:tmk_core/common/action.c **** #else
  85               		.loc 1 105 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE103:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB105:
 115:tmk_core/common/action.c **** 
 116:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 117:tmk_core/common/action.c **** bool swap_hands = false;
 118:tmk_core/common/action.c **** bool swap_held  = false;
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** /** \brief Process Hand Swap
 121:tmk_core/common/action.c ****  *
 122:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 123:tmk_core/common/action.c ****  */
 124:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 125:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 126:tmk_core/common/action.c **** 
 127:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 128:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 129:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     if (do_swap) {
 132:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 133:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 134:tmk_core/common/action.c ****     } else {
 135:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 136:tmk_core/common/action.c ****     }
 137:tmk_core/common/action.c **** }
 138:tmk_core/common/action.c **** #endif
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 141:tmk_core/common/action.c **** bool disable_action_cache = false;
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 144:tmk_core/common/action.c ****     disable_action_cache = true;
 145:tmk_core/common/action.c ****     process_record(record);
 146:tmk_core/common/action.c ****     disable_action_cache = false;
 147:tmk_core/common/action.c **** }
 148:tmk_core/common/action.c **** #else
 149:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 150:tmk_core/common/action.c **** #endif
 151:tmk_core/common/action.c **** 
 152:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 152 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 152 74 view .LVU11
 104               		.loc 1 152 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 152 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE105:
 113               		.section	.text.process_record_tap_hint,"ax",@progbits
 114               	.global	process_record_tap_hint
 116               	process_record_tap_hint:
 117               	.LVL6:
 118               	.LFB106:
 153:tmk_core/common/action.c **** 
 154:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 155:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 156:tmk_core/common/action.c ****  *
 157:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 158:tmk_core/common/action.c ****  */
 159:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 119               		.loc 1 159 51 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 160:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 125               		.loc 1 160 5 view .LVU15
 126               		.loc 1 160 23 is_stmt 0 view .LVU16
 127 0000 FC01      		movw r30,r24
 128 0002 8081      		ld r24,Z
 129 0004 9181      		ldd r25,Z+1
 130               	.LVL7:
 131               		.loc 1 160 23 view .LVU17
 132 0006 0C94 0000 		jmp layer_switch_get_action
 133               	.LVL8:
 134               		.loc 1 160 23 view .LVU18
 135               		.cfi_endproc
 136               	.LFE106:
 138               		.section	.text.register_code,"ax",@progbits
 139               	.global	register_code
 141               	register_code:
 142               	.LVL9:
 143               	.LFB109:
 161:tmk_core/common/action.c **** 
 162:tmk_core/common/action.c ****     switch (action.kind.id) {
 163:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 164:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 165:tmk_core/common/action.c ****             switch (action.swap.code) {
 166:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 167:tmk_core/common/action.c ****                 default:
 168:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 169:tmk_core/common/action.c ****                     swap_held  = true;
 170:tmk_core/common/action.c ****             }
 171:tmk_core/common/action.c ****             break;
 172:tmk_core/common/action.c **** #    endif
 173:tmk_core/common/action.c ****     }
 174:tmk_core/common/action.c **** }
 175:tmk_core/common/action.c **** #endif
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 178:tmk_core/common/action.c ****  *
 179:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 180:tmk_core/common/action.c ****  */
 181:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 182:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 183:tmk_core/common/action.c ****         return;
 184:tmk_core/common/action.c ****     }
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 187:tmk_core/common/action.c **** 
 188:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 189:tmk_core/common/action.c ****     dprint("ACTION: ");
 190:tmk_core/common/action.c ****     debug_action(action);
 191:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 192:tmk_core/common/action.c ****     dprint(" layer_state: ");
 193:tmk_core/common/action.c ****     layer_debug();
 194:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 195:tmk_core/common/action.c ****     default_layer_debug();
 196:tmk_core/common/action.c **** #endif
 197:tmk_core/common/action.c ****     dprintln();
 198:tmk_core/common/action.c **** 
 199:tmk_core/common/action.c ****     process_action(record, action);
 200:tmk_core/common/action.c **** }
 201:tmk_core/common/action.c **** 
 202:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 203:tmk_core/common/action.c ****  *
 204:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 205:tmk_core/common/action.c ****  */
 206:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 207:tmk_core/common/action.c ****     keyevent_t event = record->event;
 208:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 209:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 210:tmk_core/common/action.c **** #endif
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     if (event.pressed) {
 213:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 214:tmk_core/common/action.c ****         clear_weak_mods();
 215:tmk_core/common/action.c ****     }
 216:tmk_core/common/action.c **** 
 217:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 218:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 219:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 220:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 221:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 222:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 223:tmk_core/common/action.c ****     }
 224:tmk_core/common/action.c **** #endif
 225:tmk_core/common/action.c **** 
 226:tmk_core/common/action.c ****     switch (action.kind.id) {
 227:tmk_core/common/action.c ****         /* Key and Mods */
 228:tmk_core/common/action.c ****         case ACT_LMODS:
 229:tmk_core/common/action.c ****         case ACT_RMODS: {
 230:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 231:tmk_core/common/action.c ****             if (event.pressed) {
 232:tmk_core/common/action.c ****                 if (mods) {
 233:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 234:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 235:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 236:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 237:tmk_core/common/action.c ****                         add_mods(mods);
 238:tmk_core/common/action.c ****                     } else {
 239:tmk_core/common/action.c ****                         add_weak_mods(mods);
 240:tmk_core/common/action.c ****                     }
 241:tmk_core/common/action.c ****                     send_keyboard_report();
 242:tmk_core/common/action.c ****                 }
 243:tmk_core/common/action.c ****                 register_code(action.key.code);
 244:tmk_core/common/action.c ****             } else {
 245:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 246:tmk_core/common/action.c ****                 if (mods) {
 247:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 248:tmk_core/common/action.c ****                         del_mods(mods);
 249:tmk_core/common/action.c ****                     } else {
 250:tmk_core/common/action.c ****                         del_weak_mods(mods);
 251:tmk_core/common/action.c ****                     }
 252:tmk_core/common/action.c ****                     send_keyboard_report();
 253:tmk_core/common/action.c ****                 }
 254:tmk_core/common/action.c ****             }
 255:tmk_core/common/action.c ****         } break;
 256:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 257:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 258:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 259:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 260:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 261:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 262:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 263:tmk_core/common/action.c ****                     // Oneshot modifier
 264:tmk_core/common/action.c ****                     if (event.pressed) {
 265:tmk_core/common/action.c ****                         if (tap_count == 0) {
 266:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 267:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 268:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 269:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 270:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 272:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 273:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 274:tmk_core/common/action.c ****                             clear_oneshot_mods();
 275:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 276:tmk_core/common/action.c ****                             register_mods(mods);
 277:tmk_core/common/action.c **** #        endif
 278:tmk_core/common/action.c ****                         } else {
 279:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 280:tmk_core/common/action.c ****                         }
 281:tmk_core/common/action.c ****                     } else {
 282:tmk_core/common/action.c ****                         if (tap_count == 0) {
 283:tmk_core/common/action.c ****                             clear_oneshot_mods();
 284:tmk_core/common/action.c ****                             unregister_mods(mods);
 285:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 286:tmk_core/common/action.c ****                             // Retain Oneshot mods
 287:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 288:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 289:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 290:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 291:tmk_core/common/action.c ****                                 unregister_mods(mods);
 292:tmk_core/common/action.c ****                             }
 293:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 294:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 295:tmk_core/common/action.c **** #        endif
 296:tmk_core/common/action.c ****                         } else {
 297:tmk_core/common/action.c ****                             clear_oneshot_mods();
 298:tmk_core/common/action.c ****                             unregister_mods(mods);
 299:tmk_core/common/action.c ****                         }
 300:tmk_core/common/action.c ****                     }
 301:tmk_core/common/action.c ****                     break;
 302:tmk_core/common/action.c **** #    endif
 303:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 304:tmk_core/common/action.c ****                     if (event.pressed) {
 305:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 306:tmk_core/common/action.c ****                             register_mods(mods);
 307:tmk_core/common/action.c ****                         }
 308:tmk_core/common/action.c ****                     } else {
 309:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 310:tmk_core/common/action.c ****                             unregister_mods(mods);
 311:tmk_core/common/action.c ****                         }
 312:tmk_core/common/action.c ****                     }
 313:tmk_core/common/action.c ****                     break;
 314:tmk_core/common/action.c ****                 default:
 315:tmk_core/common/action.c ****                     if (event.pressed) {
 316:tmk_core/common/action.c ****                         if (tap_count > 0) {
 317:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 318:tmk_core/common/action.c ****                             if (
 319:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 320:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event)) &&
 321:tmk_core/common/action.c **** #        endif
 322:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 323:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 324:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 325:tmk_core/common/action.c ****                                 record->tap.count = 0;
 326:tmk_core/common/action.c ****                                 register_mods(mods);
 327:tmk_core/common/action.c ****                             } else
 328:tmk_core/common/action.c **** #    endif
 329:tmk_core/common/action.c ****                             {
 330:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 331:tmk_core/common/action.c ****                                 register_code(action.key.code);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                         } else {
 334:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 335:tmk_core/common/action.c ****                             register_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     } else {
 338:tmk_core/common/action.c ****                         if (tap_count > 0) {
 339:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 340:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 341:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 342:tmk_core/common/action.c ****                             }
 343:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 344:tmk_core/common/action.c ****                         } else {
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 346:tmk_core/common/action.c ****                             unregister_mods(mods);
 347:tmk_core/common/action.c ****                         }
 348:tmk_core/common/action.c ****                     }
 349:tmk_core/common/action.c ****                     break;
 350:tmk_core/common/action.c ****             }
 351:tmk_core/common/action.c ****         } break;
 352:tmk_core/common/action.c **** #endif
 353:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 354:tmk_core/common/action.c ****         /* other HID usage */
 355:tmk_core/common/action.c ****         case ACT_USAGE:
 356:tmk_core/common/action.c ****             switch (action.usage.page) {
 357:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 358:tmk_core/common/action.c ****                     if (event.pressed) {
 359:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 360:tmk_core/common/action.c ****                     } else {
 361:tmk_core/common/action.c ****                         host_system_send(0);
 362:tmk_core/common/action.c ****                     }
 363:tmk_core/common/action.c ****                     break;
 364:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 365:tmk_core/common/action.c ****                     if (event.pressed) {
 366:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 367:tmk_core/common/action.c ****                     } else {
 368:tmk_core/common/action.c ****                         host_consumer_send(0);
 369:tmk_core/common/action.c ****                     }
 370:tmk_core/common/action.c ****                     break;
 371:tmk_core/common/action.c ****             }
 372:tmk_core/common/action.c ****             break;
 373:tmk_core/common/action.c **** #endif
 374:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 375:tmk_core/common/action.c ****         /* Mouse key */
 376:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 377:tmk_core/common/action.c ****             if (event.pressed) {
 378:tmk_core/common/action.c ****                 switch (action.key.code) {
 379:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 380:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 381:tmk_core/common/action.c ****                         break;
 382:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 383:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 386:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     default:
 389:tmk_core/common/action.c ****                         break;
 390:tmk_core/common/action.c ****                 }
 391:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 392:tmk_core/common/action.c ****                 mousekey_send();
 393:tmk_core/common/action.c ****             } else {
 394:tmk_core/common/action.c ****                 switch (action.key.code) {
 395:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 396:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 397:tmk_core/common/action.c ****                         break;
 398:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 399:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 400:tmk_core/common/action.c ****                         break;
 401:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 402:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 403:tmk_core/common/action.c ****                         break;
 404:tmk_core/common/action.c ****                     default:
 405:tmk_core/common/action.c ****                         break;
 406:tmk_core/common/action.c ****                 }
 407:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 408:tmk_core/common/action.c ****                 mousekey_send();
 409:tmk_core/common/action.c ****             }
 410:tmk_core/common/action.c ****             break;
 411:tmk_core/common/action.c **** #endif
 412:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 413:tmk_core/common/action.c ****         case ACT_LAYER:
 414:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 415:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 416:tmk_core/common/action.c ****                 if (!event.pressed) {
 417:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 418:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 419:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 420:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 421:tmk_core/common/action.c ****                         case OP_BIT_AND:
 422:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 423:tmk_core/common/action.c ****                             break;
 424:tmk_core/common/action.c ****                         case OP_BIT_OR:
 425:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 426:tmk_core/common/action.c ****                             break;
 427:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 428:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 429:tmk_core/common/action.c ****                             break;
 430:tmk_core/common/action.c ****                         case OP_BIT_SET:
 431:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 432:tmk_core/common/action.c ****                             break;
 433:tmk_core/common/action.c ****                     }
 434:tmk_core/common/action.c ****                 }
 435:tmk_core/common/action.c ****             } else {
 436:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 437:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 438:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 439:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 440:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 441:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 442:tmk_core/common/action.c ****                         case OP_BIT_AND:
 443:tmk_core/common/action.c ****                             layer_and(bits | mask);
 444:tmk_core/common/action.c ****                             break;
 445:tmk_core/common/action.c ****                         case OP_BIT_OR:
 446:tmk_core/common/action.c ****                             layer_or(bits | mask);
 447:tmk_core/common/action.c ****                             break;
 448:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 449:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 450:tmk_core/common/action.c ****                             break;
 451:tmk_core/common/action.c ****                         case OP_BIT_SET:
 452:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 453:tmk_core/common/action.c ****                             break;
 454:tmk_core/common/action.c ****                     }
 455:tmk_core/common/action.c ****                 }
 456:tmk_core/common/action.c ****             }
 457:tmk_core/common/action.c ****             break;
 458:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 459:tmk_core/common/action.c ****             if (event.pressed) {
 460:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 461:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 462:tmk_core/common/action.c ****             } else {
 463:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 464:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 465:tmk_core/common/action.c ****             }
 466:tmk_core/common/action.c ****             break;
 467:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 468:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 469:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 470:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 471:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 472:tmk_core/common/action.c ****                     /* tap toggle */
 473:tmk_core/common/action.c ****                     if (event.pressed) {
 474:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 475:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 476:tmk_core/common/action.c ****                         }
 477:tmk_core/common/action.c ****                     } else {
 478:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 479:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 480:tmk_core/common/action.c ****                         }
 481:tmk_core/common/action.c ****                     }
 482:tmk_core/common/action.c ****                     break;
 483:tmk_core/common/action.c ****                 case OP_ON_OFF:
 484:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 485:tmk_core/common/action.c ****                     break;
 486:tmk_core/common/action.c ****                 case OP_OFF_ON:
 487:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 488:tmk_core/common/action.c ****                     break;
 489:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 490:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 491:tmk_core/common/action.c ****                     break;
 492:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 493:tmk_core/common/action.c ****                 case OP_ONESHOT:
 494:tmk_core/common/action.c ****                     // Oneshot modifier
 495:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 496:tmk_core/common/action.c ****                     do_release_oneshot = false;
 497:tmk_core/common/action.c ****                     if (event.pressed) {
 498:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 499:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 500:tmk_core/common/action.c ****                             reset_oneshot_layer();
 501:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 502:tmk_core/common/action.c ****                             break;
 503:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 504:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 505:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 506:tmk_core/common/action.c ****                         }
 507:tmk_core/common/action.c ****                     } else {
 508:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 509:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 510:tmk_core/common/action.c ****                             reset_oneshot_layer();
 511:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 512:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 513:tmk_core/common/action.c ****                         } else {
 514:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 515:tmk_core/common/action.c ****                         }
 516:tmk_core/common/action.c ****                     }
 517:tmk_core/common/action.c **** #            else
 518:tmk_core/common/action.c ****                     if (event.pressed) {
 519:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 520:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 521:tmk_core/common/action.c ****                     } else {
 522:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 523:tmk_core/common/action.c ****                         if (tap_count > 1) {
 524:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 525:tmk_core/common/action.c ****                         }
 526:tmk_core/common/action.c ****                     }
 527:tmk_core/common/action.c **** #            endif
 528:tmk_core/common/action.c ****                     break;
 529:tmk_core/common/action.c **** #        endif
 530:tmk_core/common/action.c ****                 default:
 531:tmk_core/common/action.c ****                     /* tap key */
 532:tmk_core/common/action.c ****                     if (event.pressed) {
 533:tmk_core/common/action.c ****                         if (tap_count > 0) {
 534:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 535:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 536:tmk_core/common/action.c ****                         } else {
 537:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 538:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 539:tmk_core/common/action.c ****                         }
 540:tmk_core/common/action.c ****                     } else {
 541:tmk_core/common/action.c ****                         if (tap_count > 0) {
 542:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 543:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 544:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 545:tmk_core/common/action.c ****                             } else {
 546:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 547:tmk_core/common/action.c ****                             }
 548:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 549:tmk_core/common/action.c ****                         } else {
 550:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 551:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 552:tmk_core/common/action.c ****                         }
 553:tmk_core/common/action.c ****                     }
 554:tmk_core/common/action.c ****                     break;
 555:tmk_core/common/action.c ****             }
 556:tmk_core/common/action.c ****             break;
 557:tmk_core/common/action.c **** #    endif
 558:tmk_core/common/action.c **** #endif
 559:tmk_core/common/action.c ****             /* Extentions */
 560:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 561:tmk_core/common/action.c ****         case ACT_MACRO:
 562:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 563:tmk_core/common/action.c ****             break;
 564:tmk_core/common/action.c **** #endif
 565:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) || defined(LED_MATRIX_ENABLE)
 566:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 567:tmk_core/common/action.c ****             if (!event.pressed) {
 568:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 569:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 570:tmk_core/common/action.c ****                         backlight_increase();
 571:tmk_core/common/action.c ****                         break;
 572:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 573:tmk_core/common/action.c ****                         backlight_decrease();
 574:tmk_core/common/action.c ****                         break;
 575:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 576:tmk_core/common/action.c ****                         backlight_toggle();
 577:tmk_core/common/action.c ****                         break;
 578:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 579:tmk_core/common/action.c ****                         backlight_step();
 580:tmk_core/common/action.c ****                         break;
 581:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 582:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 583:tmk_core/common/action.c ****                         break;
 584:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 585:tmk_core/common/action.c ****                         backlight_level(0);
 586:tmk_core/common/action.c ****                         break;
 587:tmk_core/common/action.c ****                 }
 588:tmk_core/common/action.c ****             }
 589:tmk_core/common/action.c ****             break;
 590:tmk_core/common/action.c **** #endif
 591:tmk_core/common/action.c ****         case ACT_COMMAND:
 592:tmk_core/common/action.c ****             break;
 593:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 594:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 595:tmk_core/common/action.c ****             switch (action.swap.code) {
 596:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 597:tmk_core/common/action.c ****                     if (event.pressed) {
 598:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 599:tmk_core/common/action.c ****                     }
 600:tmk_core/common/action.c ****                     break;
 601:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 602:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 605:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_ON:
 608:tmk_core/common/action.c ****                     if (!event.pressed) {
 609:tmk_core/common/action.c ****                         swap_hands = true;
 610:tmk_core/common/action.c ****                     }
 611:tmk_core/common/action.c ****                     break;
 612:tmk_core/common/action.c ****                 case OP_SH_OFF:
 613:tmk_core/common/action.c ****                     if (!event.pressed) {
 614:tmk_core/common/action.c ****                         swap_hands = false;
 615:tmk_core/common/action.c ****                     }
 616:tmk_core/common/action.c ****                     break;
 617:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 618:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 619:tmk_core/common/action.c ****                     /* tap toggle */
 620:tmk_core/common/action.c **** 
 621:tmk_core/common/action.c ****                     if (event.pressed) {
 622:tmk_core/common/action.c ****                         if (swap_held) {
 623:tmk_core/common/action.c ****                             swap_held = false;
 624:tmk_core/common/action.c ****                         } else {
 625:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 626:tmk_core/common/action.c ****                         }
 627:tmk_core/common/action.c ****                     } else {
 628:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 629:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 630:tmk_core/common/action.c ****                         }
 631:tmk_core/common/action.c ****                     }
 632:tmk_core/common/action.c ****                     break;
 633:tmk_core/common/action.c ****                 default:
 634:tmk_core/common/action.c ****                     /* tap key */
 635:tmk_core/common/action.c ****                     if (tap_count > 0) {
 636:tmk_core/common/action.c ****                         if (swap_held) {
 637:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 638:tmk_core/common/action.c ****                             swap_held  = false;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                         if (event.pressed) {
 641:tmk_core/common/action.c ****                             register_code(action.swap.code);
 642:tmk_core/common/action.c ****                         } else {
 643:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 644:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 645:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 646:tmk_core/common/action.c ****                         }
 647:tmk_core/common/action.c ****                     } else {
 648:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 649:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:tmk_core/common/action.c ****                             swap_held  = false;
 651:tmk_core/common/action.c ****                         }
 652:tmk_core/common/action.c ****                     }
 653:tmk_core/common/action.c **** #    endif
 654:tmk_core/common/action.c ****             }
 655:tmk_core/common/action.c **** #endif
 656:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 657:tmk_core/common/action.c ****         case ACT_FUNCTION:
 658:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 659:tmk_core/common/action.c ****             break;
 660:tmk_core/common/action.c **** #endif
 661:tmk_core/common/action.c ****         default:
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****     }
 664:tmk_core/common/action.c **** 
 665:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 666:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 667:tmk_core/common/action.c ****     switch (action.kind.id) {
 668:tmk_core/common/action.c ****         case ACT_LAYER:
 669:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 670:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 671:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 672:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 673:tmk_core/common/action.c **** #    endif
 674:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****         default:
 677:tmk_core/common/action.c ****             break;
 678:tmk_core/common/action.c ****     }
 679:tmk_core/common/action.c **** #endif
 680:tmk_core/common/action.c **** 
 681:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 682:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 683:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 684:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 685:tmk_core/common/action.c ****     } else {
 686:tmk_core/common/action.c ****         if (event.pressed) {
 687:tmk_core/common/action.c ****             if (tap_count > 0) {
 688:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 689:tmk_core/common/action.c ****             } else {
 690:tmk_core/common/action.c ****             }
 691:tmk_core/common/action.c ****         } else {
 692:tmk_core/common/action.c ****             if (tap_count > 0) {
 693:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 694:tmk_core/common/action.c ****             } else {
 695:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 696:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 697:tmk_core/common/action.c ****                 }
 698:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 699:tmk_core/common/action.c ****             }
 700:tmk_core/common/action.c ****         }
 701:tmk_core/common/action.c ****     }
 702:tmk_core/common/action.c **** #    endif
 703:tmk_core/common/action.c **** #endif
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 706:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 707:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 708:tmk_core/common/action.c ****      */
 709:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 710:tmk_core/common/action.c ****         record->event.pressed = false;
 711:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 712:tmk_core/common/action.c ****         process_record(record);
 713:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #endif
 716:tmk_core/common/action.c **** }
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 719:tmk_core/common/action.c ****  *
 720:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 721:tmk_core/common/action.c ****  */
 722:tmk_core/common/action.c **** void register_code(uint8_t code) {
 144               		.loc 1 722 34 is_stmt 1 view -0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
 723:tmk_core/common/action.c ****     if (code == KC_NO) {
 150               		.loc 1 723 5 view .LVU20
 151               		.loc 1 723 8 is_stmt 0 view .LVU21
 152 0000 8823      		tst r24
 153 0002 01F4      		brne .+2
 154 0004 00C0      		rjmp .L4
 724:tmk_core/common/action.c ****         return;
 725:tmk_core/common/action.c ****     }
 726:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 727:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 155               		.loc 1 727 10 is_stmt 1 view .LVU22
 156               		.loc 1 727 13 is_stmt 0 view .LVU23
 157 0006 8238      		cpi r24,lo8(-126)
 158 0008 01F4      		brne .L7
 728:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 729:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 730:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 159               		.loc 1 730 9 is_stmt 1 view .LVU24
 160               		.loc 1 730 13 is_stmt 0 view .LVU25
 161 000a 0E94 0000 		call host_keyboard_leds
 162               	.LVL10:
 163               		.loc 1 730 12 view .LVU26
 164 000e 81FD      		sbrc r24,1
 165 0010 00C0      		rjmp .L4
 731:tmk_core/common/action.c **** #    endif
 732:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 166               		.loc 1 732 9 is_stmt 1 view .LVU27
 167 0012 89E3      		ldi r24,lo8(57)
 168 0014 0E94 0000 		call add_key
 169               	.LVL11:
 733:tmk_core/common/action.c ****         send_keyboard_report();
 170               		.loc 1 733 9 view .LVU28
 171 0018 0E94 0000 		call send_keyboard_report
 172               	.LVL12:
 734:tmk_core/common/action.c ****         wait_ms(100);
 173               		.loc 1 734 9 view .LVU29
 174               	.LBB32:
 175               	.LBI32:
 176               		.file 2 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchain
   1:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 177               		.loc 2 166 1 view .LVU30
 178               	.LBB33:
 167:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 179               		.loc 2 168 2 view .LVU31
 169:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 180               		.loc 2 172 2 view .LVU32
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 181               		.loc 2 173 2 view .LVU33
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 182               		.loc 2 174 2 view .LVU34
 175:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 183               		.loc 2 184 3 view .LVU35
 185:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 184               		.loc 2 187 2 view .LVU36
 185 001c 2FEF      		ldi r18,lo8(319999)
 186 001e 81EE      		ldi r24,hi8(319999)
 187 0020 94E0      		ldi r25,hlo8(319999)
 188 0022 2150      	1:	subi r18,1
 189 0024 8040      		sbci r24,0
 190 0026 9040      		sbci r25,0
 191 0028 01F4      		brne 1b
 192 002a 00C0      		rjmp .
 193 002c 0000      		nop
 194               	.LVL13:
 195               		.loc 2 187 2 is_stmt 0 view .LVU37
 196               	.LBE33:
 197               	.LBE32:
 735:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 198               		.loc 1 735 9 is_stmt 1 view .LVU38
 199 002e 89E3      		ldi r24,lo8(57)
 200               	.L15:
 736:tmk_core/common/action.c ****         send_keyboard_report();
 737:tmk_core/common/action.c ****     }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 740:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 741:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 742:tmk_core/common/action.c **** #    endif
 743:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 744:tmk_core/common/action.c ****         send_keyboard_report();
 745:tmk_core/common/action.c ****         wait_ms(100);
 746:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 201               		.loc 1 746 9 is_stmt 0 view .LVU39
 202 0030 0E94 0000 		call del_key
 203               	.LVL14:
 204               	.L16:
 747:tmk_core/common/action.c ****         send_keyboard_report();
 205               		.loc 1 747 9 is_stmt 1 view .LVU40
 206 0034 0C94 0000 		jmp send_keyboard_report
 207               	.LVL15:
 208               	.L7:
 739:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 209               		.loc 1 739 10 view .LVU41
 739:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 210               		.loc 1 739 13 is_stmt 0 view .LVU42
 211 0038 8338      		cpi r24,lo8(-125)
 212 003a 01F4      		brne .L9
 741:tmk_core/common/action.c **** #    endif
 213               		.loc 1 741 9 is_stmt 1 view .LVU43
 741:tmk_core/common/action.c **** #    endif
 214               		.loc 1 741 13 is_stmt 0 view .LVU44
 215 003c 0E94 0000 		call host_keyboard_leds
 216               	.LVL16:
 741:tmk_core/common/action.c **** #    endif
 217               		.loc 1 741 12 view .LVU45
 218 0040 80FD      		sbrc r24,0
 219 0042 00C0      		rjmp .L4
 743:tmk_core/common/action.c ****         send_keyboard_report();
 220               		.loc 1 743 9 is_stmt 1 view .LVU46
 221 0044 83E5      		ldi r24,lo8(83)
 222 0046 0E94 0000 		call add_key
 223               	.LVL17:
 744:tmk_core/common/action.c ****         wait_ms(100);
 224               		.loc 1 744 9 view .LVU47
 225 004a 0E94 0000 		call send_keyboard_report
 226               	.LVL18:
 745:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 227               		.loc 1 745 9 view .LVU48
 228               	.LBB34:
 229               	.LBI34:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 230               		.loc 2 166 1 view .LVU49
 231               	.LBB35:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 232               		.loc 2 168 2 view .LVU50
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233               		.loc 2 172 2 view .LVU51
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 234               		.loc 2 173 2 view .LVU52
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 235               		.loc 2 174 2 view .LVU53
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 236               		.loc 2 184 3 view .LVU54
 237               		.loc 2 187 2 view .LVU55
 238 004e 2FEF      		ldi r18,lo8(319999)
 239 0050 81EE      		ldi r24,hi8(319999)
 240 0052 94E0      		ldi r25,hlo8(319999)
 241 0054 2150      	1:	subi r18,1
 242 0056 8040      		sbci r24,0
 243 0058 9040      		sbci r25,0
 244 005a 01F4      		brne 1b
 245 005c 00C0      		rjmp .
 246 005e 0000      		nop
 247               	.LVL19:
 248               		.loc 2 187 2 is_stmt 0 view .LVU56
 249               	.LBE35:
 250               	.LBE34:
 746:tmk_core/common/action.c ****         send_keyboard_report();
 251               		.loc 1 746 9 is_stmt 1 view .LVU57
 252 0060 83E5      		ldi r24,lo8(83)
 253 0062 00C0      		rjmp .L15
 254               	.LVL20:
 255               	.L9:
 748:tmk_core/common/action.c ****     }
 749:tmk_core/common/action.c **** 
 750:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 256               		.loc 1 750 10 view .LVU58
 257               		.loc 1 750 13 is_stmt 0 view .LVU59
 258 0064 8438      		cpi r24,lo8(-124)
 259 0066 01F4      		brne .L10
 751:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 260               		.loc 1 752 9 is_stmt 1 view .LVU60
 261               		.loc 1 752 13 is_stmt 0 view .LVU61
 262 0068 0E94 0000 		call host_keyboard_leds
 263               	.LVL21:
 264               		.loc 1 752 12 view .LVU62
 265 006c 82FD      		sbrc r24,2
 266 006e 00C0      		rjmp .L4
 753:tmk_core/common/action.c **** #    endif
 754:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 267               		.loc 1 754 9 is_stmt 1 view .LVU63
 268 0070 87E4      		ldi r24,lo8(71)
 269 0072 0E94 0000 		call add_key
 270               	.LVL22:
 755:tmk_core/common/action.c ****         send_keyboard_report();
 271               		.loc 1 755 9 view .LVU64
 272 0076 0E94 0000 		call send_keyboard_report
 273               	.LVL23:
 756:tmk_core/common/action.c ****         wait_ms(100);
 274               		.loc 1 756 9 view .LVU65
 275               	.LBB36:
 276               	.LBI36:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 277               		.loc 2 166 1 view .LVU66
 278               	.LBB37:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 279               		.loc 2 168 2 view .LVU67
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 280               		.loc 2 172 2 view .LVU68
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 281               		.loc 2 173 2 view .LVU69
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 282               		.loc 2 174 2 view .LVU70
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 283               		.loc 2 184 3 view .LVU71
 284               		.loc 2 187 2 view .LVU72
 285 007a 2FEF      		ldi r18,lo8(319999)
 286 007c 81EE      		ldi r24,hi8(319999)
 287 007e 94E0      		ldi r25,hlo8(319999)
 288 0080 2150      	1:	subi r18,1
 289 0082 8040      		sbci r24,0
 290 0084 9040      		sbci r25,0
 291 0086 01F4      		brne 1b
 292 0088 00C0      		rjmp .
 293 008a 0000      		nop
 294               	.LVL24:
 295               		.loc 2 187 2 is_stmt 0 view .LVU73
 296               	.LBE37:
 297               	.LBE36:
 757:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 298               		.loc 1 757 9 is_stmt 1 view .LVU74
 299 008c 87E4      		ldi r24,lo8(71)
 300 008e 00C0      		rjmp .L15
 301               	.LVL25:
 302               	.L10:
 758:tmk_core/common/action.c ****         send_keyboard_report();
 759:tmk_core/common/action.c ****     }
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c **** 
 762:tmk_core/common/action.c ****     else if
 303               		.loc 1 762 10 view .LVU75
 763:tmk_core/common/action.c ****         IS_KEY(code) {
 304               		.loc 1 763 9 is_stmt 0 view .LVU76
 305 0090 9CEF      		ldi r25,lo8(-4)
 306 0092 980F      		add r25,r24
 307 0094 913A      		cpi r25,lo8(-95)
 308 0096 00F4      		brsh .L11
 764:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 765:tmk_core/common/action.c ****             if (command_proc(code)) return;
 309               		.loc 1 765 13 is_stmt 1 view .LVU77
 766:tmk_core/common/action.c **** 
 767:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 768:tmk_core/common/action.c **** /* TODO: remove
 769:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 770:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 771:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 772:tmk_core/common/action.c **** 
 773:tmk_core/common/action.c ****             add_key(code);
 774:tmk_core/common/action.c ****             send_keyboard_report();
 775:tmk_core/common/action.c **** 
 776:tmk_core/common/action.c ****             set_mods(tmp_mods);
 777:tmk_core/common/action.c ****             send_keyboard_report();
 778:tmk_core/common/action.c ****             oneshot_cancel();
 779:tmk_core/common/action.c ****         } else
 780:tmk_core/common/action.c **** */
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c ****             {
 783:tmk_core/common/action.c ****                 add_key(code);
 310               		.loc 1 783 17 view .LVU78
 311 0098 0E94 0000 		call add_key
 312               	.LVL26:
 784:tmk_core/common/action.c ****                 send_keyboard_report();
 313               		.loc 1 784 17 view .LVU79
 314 009c 00C0      		rjmp .L16
 315               	.LVL27:
 316               	.L11:
 785:tmk_core/common/action.c ****             }
 786:tmk_core/common/action.c ****         }
 787:tmk_core/common/action.c ****     else if
 317               		.loc 1 787 10 view .LVU80
 788:tmk_core/common/action.c ****         IS_MOD(code) {
 318               		.loc 1 788 9 is_stmt 0 view .LVU81
 319 009e 90E2      		ldi r25,lo8(32)
 320 00a0 980F      		add r25,r24
 321 00a2 9830      		cpi r25,lo8(8)
 322 00a4 00F4      		brsh .L12
 789:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 323               		.loc 1 789 13 is_stmt 1 view .LVU82
 324               		.loc 1 789 22 is_stmt 0 view .LVU83
 325 00a6 8770      		andi r24,lo8(7)
 326               	.LVL28:
 327               		.loc 1 789 13 view .LVU84
 328 00a8 91E0      		ldi r25,lo8(1)
 329 00aa 00C0      		rjmp 2f
 330               		1:
 331 00ac 990F      		lsl r25
 332               		2:
 333 00ae 8A95      		dec r24
 334 00b0 02F4      		brpl 1b
 335 00b2 892F      		mov r24,r25
 336 00b4 0E94 0000 		call add_mods
 337               	.LVL29:
 790:tmk_core/common/action.c ****             send_keyboard_report();
 338               		.loc 1 790 13 is_stmt 1 view .LVU85
 339 00b8 00C0      		rjmp .L16
 340               	.LVL30:
 341               	.L12:
 791:tmk_core/common/action.c ****         }
 792:tmk_core/common/action.c ****     else if
 342               		.loc 1 792 10 view .LVU86
 793:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 343               		.loc 1 793 9 is_stmt 0 view .LVU87
 344 00ba EBE5      		ldi r30,lo8(91)
 345 00bc E80F      		add r30,r24
 346 00be E330      		cpi r30,lo8(3)
 347 00c0 00F4      		brsh .L13
 348               		.loc 1 793 27 is_stmt 1 view .LVU88
 349               	.LVL31:
 350               	.LBB38:
 351               	.LBI38:
 352               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #ifndef REPORT_H
  19:tmk_core/common/report.h **** #define REPORT_H
  20:tmk_core/common/report.h **** 
  21:tmk_core/common/report.h **** #include <stdint.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** /* report id */
  25:tmk_core/common/report.h **** #define REPORT_ID_KEYBOARD 1
  26:tmk_core/common/report.h **** #define REPORT_ID_MOUSE 2
  27:tmk_core/common/report.h **** #define REPORT_ID_SYSTEM 3
  28:tmk_core/common/report.h **** #define REPORT_ID_CONSUMER 4
  29:tmk_core/common/report.h **** #define REPORT_ID_NKRO 5
  30:tmk_core/common/report.h **** 
  31:tmk_core/common/report.h **** /* mouse buttons */
  32:tmk_core/common/report.h **** #define MOUSE_BTN1 (1 << 0)
  33:tmk_core/common/report.h **** #define MOUSE_BTN2 (1 << 1)
  34:tmk_core/common/report.h **** #define MOUSE_BTN3 (1 << 2)
  35:tmk_core/common/report.h **** #define MOUSE_BTN4 (1 << 3)
  36:tmk_core/common/report.h **** #define MOUSE_BTN5 (1 << 4)
  37:tmk_core/common/report.h **** 
  38:tmk_core/common/report.h **** /* Consumer Page(0x0C)
  39:tmk_core/common/report.h ****  * following are supported by Windows: http://msdn.microsoft.com/en-us/windows/hardware/gg463372.as
  40:tmk_core/common/report.h ****  * see also https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/display-brightness-contro
  41:tmk_core/common/report.h ****  */
  42:tmk_core/common/report.h **** #define AUDIO_MUTE 0x00E2
  43:tmk_core/common/report.h **** #define AUDIO_VOL_UP 0x00E9
  44:tmk_core/common/report.h **** #define AUDIO_VOL_DOWN 0x00EA
  45:tmk_core/common/report.h **** #define TRANSPORT_NEXT_TRACK 0x00B5
  46:tmk_core/common/report.h **** #define TRANSPORT_PREV_TRACK 0x00B6
  47:tmk_core/common/report.h **** #define TRANSPORT_STOP 0x00B7
  48:tmk_core/common/report.h **** #define TRANSPORT_STOP_EJECT 0x00CC
  49:tmk_core/common/report.h **** #define TRANSPORT_PLAY_PAUSE 0x00CD
  50:tmk_core/common/report.h **** #define BRIGHTNESS_UP 0x006F
  51:tmk_core/common/report.h **** #define BRIGHTNESS_DOWN 0x0070
  52:tmk_core/common/report.h **** /* application launch */
  53:tmk_core/common/report.h **** #define AL_CC_CONFIG 0x0183
  54:tmk_core/common/report.h **** #define AL_EMAIL 0x018A
  55:tmk_core/common/report.h **** #define AL_CALCULATOR 0x0192
  56:tmk_core/common/report.h **** #define AL_LOCAL_BROWSER 0x0194
  57:tmk_core/common/report.h **** /* application control */
  58:tmk_core/common/report.h **** #define AC_SEARCH 0x0221
  59:tmk_core/common/report.h **** #define AC_HOME 0x0223
  60:tmk_core/common/report.h **** #define AC_BACK 0x0224
  61:tmk_core/common/report.h **** #define AC_FORWARD 0x0225
  62:tmk_core/common/report.h **** #define AC_STOP 0x0226
  63:tmk_core/common/report.h **** #define AC_REFRESH 0x0227
  64:tmk_core/common/report.h **** #define AC_BOOKMARKS 0x022A
  65:tmk_core/common/report.h **** /* supplement for Bluegiga iWRAP HID(not supported by Windows?) */
  66:tmk_core/common/report.h **** #define AL_LOCK 0x019E
  67:tmk_core/common/report.h **** #define TRANSPORT_RECORD 0x00B2
  68:tmk_core/common/report.h **** #define TRANSPORT_FAST_FORWARD 0x00B3
  69:tmk_core/common/report.h **** #define TRANSPORT_REWIND 0x00B4
  70:tmk_core/common/report.h **** #define TRANSPORT_EJECT 0x00B8
  71:tmk_core/common/report.h **** #define AC_MINIMIZE 0x0206
  72:tmk_core/common/report.h **** 
  73:tmk_core/common/report.h **** /* Generic Desktop Page(0x01) - system power control */
  74:tmk_core/common/report.h **** #define SYSTEM_POWER_DOWN 0x0081
  75:tmk_core/common/report.h **** #define SYSTEM_SLEEP 0x0082
  76:tmk_core/common/report.h **** #define SYSTEM_WAKE_UP 0x0083
  77:tmk_core/common/report.h **** 
  78:tmk_core/common/report.h **** #define NKRO_SHARED_EP
  79:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
  80:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
  81:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
  82:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
  83:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
  84:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
  85:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
  86:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
  87:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
  88:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
  89:tmk_core/common/report.h **** #    else
  90:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
  91:tmk_core/common/report.h **** #    endif
  92:tmk_core/common/report.h **** #endif
  93:tmk_core/common/report.h **** 
  94:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
  95:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
  96:tmk_core/common/report.h **** #else
  97:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
  98:tmk_core/common/report.h **** #endif
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 103:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 104:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 105:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 106:tmk_core/common/report.h **** #endif
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** #ifdef __cplusplus
 109:tmk_core/common/report.h **** extern "C" {
 110:tmk_core/common/report.h **** #endif
 111:tmk_core/common/report.h **** 
 112:tmk_core/common/report.h **** /*
 113:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 114:tmk_core/common/report.h ****  *
 115:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 116:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 117:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 118:tmk_core/common/report.h ****  *
 119:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 120:tmk_core/common/report.h ****  *
 121:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 122:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 123:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 124:tmk_core/common/report.h ****  *
 125:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 126:tmk_core/common/report.h ****  *
 127:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 128:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 129:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 130:tmk_core/common/report.h ****  *
 131:tmk_core/common/report.h ****  */
 132:tmk_core/common/report.h **** typedef union {
 133:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 134:tmk_core/common/report.h ****     struct {
 135:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 136:tmk_core/common/report.h ****         uint8_t report_id;
 137:tmk_core/common/report.h **** #endif
 138:tmk_core/common/report.h ****         uint8_t mods;
 139:tmk_core/common/report.h ****         uint8_t reserved;
 140:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 141:tmk_core/common/report.h ****     };
 142:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 143:tmk_core/common/report.h ****     struct nkro_report {
 144:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 145:tmk_core/common/report.h ****         uint8_t report_id;
 146:tmk_core/common/report.h **** #    endif
 147:tmk_core/common/report.h ****         uint8_t mods;
 148:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 149:tmk_core/common/report.h ****     } nkro;
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 152:tmk_core/common/report.h **** 
 153:tmk_core/common/report.h **** typedef struct {
 154:tmk_core/common/report.h ****     uint8_t  report_id;
 155:tmk_core/common/report.h ****     uint16_t usage;
 156:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 157:tmk_core/common/report.h **** 
 158:tmk_core/common/report.h **** typedef struct {
 159:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 160:tmk_core/common/report.h ****     uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****     uint8_t buttons;
 163:tmk_core/common/report.h ****     int8_t  x;
 164:tmk_core/common/report.h ****     int8_t  y;
 165:tmk_core/common/report.h ****     int8_t  v;
 166:tmk_core/common/report.h ****     int8_t  h;
 167:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 168:tmk_core/common/report.h **** 
 169:tmk_core/common/report.h **** /* keycode to system usage */
 170:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 353               		.loc 3 170 24 view .LVU89
 354               	.LBE38:
 171:tmk_core/common/report.h ****     switch (key) {
 355               		.loc 3 171 5 view .LVU90
 356               		.loc 1 793 27 is_stmt 0 view .LVU91
 357 00c2 F0E0      		ldi r31,0
 358 00c4 E050      		subi r30,lo8(-(CSWTCH.15))
 359 00c6 F040      		sbci r31,hi8(-(CSWTCH.15))
 360 00c8 8081      		ld r24,Z
 361               	.LVL32:
 362               		.loc 1 793 27 view .LVU92
 363 00ca 90E0      		ldi r25,0
 364 00cc 0C94 0000 		jmp host_system_send
 365               	.LVL33:
 366               	.L13:
 794:tmk_core/common/action.c ****     else if
 367               		.loc 1 794 10 is_stmt 1 view .LVU93
 795:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 368               		.loc 1 795 9 is_stmt 0 view .LVU94
 369 00d0 E8E5      		ldi r30,lo8(88)
 370 00d2 E80F      		add r30,r24
 371 00d4 E731      		cpi r30,lo8(23)
 372 00d6 00F4      		brsh .L14
 373               		.loc 1 795 29 is_stmt 1 view .LVU95
 374               	.LVL34:
 375               	.LBB39:
 376               	.LBI39:
 172:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 173:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 174:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 175:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 176:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 177:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 178:tmk_core/common/report.h ****         default:
 179:tmk_core/common/report.h ****             return 0;
 180:tmk_core/common/report.h ****     }
 181:tmk_core/common/report.h **** }
 182:tmk_core/common/report.h **** 
 183:tmk_core/common/report.h **** /* keycode to consumer usage */
 184:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 377               		.loc 3 184 24 view .LVU96
 378               	.LBE39:
 185:tmk_core/common/report.h ****     switch (key) {
 379               		.loc 3 185 5 view .LVU97
 380               		.loc 1 795 29 is_stmt 0 view .LVU98
 381 00d8 F0E0      		ldi r31,0
 382 00da EE0F      		lsl r30
 383 00dc FF1F      		rol r31
 384               	.LVL35:
 385               		.loc 1 795 29 view .LVU99
 386 00de E050      		subi r30,lo8(-(CSWTCH.16))
 387 00e0 F040      		sbci r31,hi8(-(CSWTCH.16))
 388 00e2 8081      		ld r24,Z
 389 00e4 9181      		ldd r25,Z+1
 390 00e6 0C94 0000 		jmp host_consumer_send
 391               	.LVL36:
 392               	.L14:
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 798:tmk_core/common/action.c ****     else if
 393               		.loc 1 798 10 is_stmt 1 view .LVU100
 799:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 394               		.loc 1 799 9 is_stmt 0 view .LVU101
 395 00ea 803F      		cpi r24,lo8(-16)
 396 00ec 00F0      		brlo .L4
 800:tmk_core/common/action.c ****             mousekey_on(code);
 397               		.loc 1 800 13 is_stmt 1 view .LVU102
 398 00ee 0E94 0000 		call mousekey_on
 399               	.LVL37:
 801:tmk_core/common/action.c ****             mousekey_send();
 400               		.loc 1 801 13 view .LVU103
 401 00f2 0C94 0000 		jmp mousekey_send
 402               	.LVL38:
 403               	.L4:
 404               	/* epilogue start */
 802:tmk_core/common/action.c ****         }
 803:tmk_core/common/action.c **** #endif
 804:tmk_core/common/action.c **** }
 405               		.loc 1 804 1 is_stmt 0 view .LVU104
 406 00f6 0895      		ret
 407               		.cfi_endproc
 408               	.LFE109:
 410               		.section	.text.unregister_code,"ax",@progbits
 411               	.global	unregister_code
 413               	unregister_code:
 414               	.LVL39:
 415               	.LFB110:
 805:tmk_core/common/action.c **** 
 806:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 807:tmk_core/common/action.c ****  *
 808:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 809:tmk_core/common/action.c ****  */
 810:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 416               		.loc 1 810 36 is_stmt 1 view -0
 417               		.cfi_startproc
 418               	/* prologue: function */
 419               	/* frame size = 0 */
 420               	/* stack size = 0 */
 421               	.L__stack_usage = 0
 811:tmk_core/common/action.c ****     if (code == KC_NO) {
 422               		.loc 1 811 5 view .LVU106
 423               		.loc 1 811 8 is_stmt 0 view .LVU107
 424 0000 8823      		tst r24
 425 0002 01F4      		brne .+2
 426 0004 00C0      		rjmp .L17
 812:tmk_core/common/action.c ****         return;
 813:tmk_core/common/action.c ****     }
 814:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 815:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 427               		.loc 1 815 10 is_stmt 1 view .LVU108
 428               		.loc 1 815 13 is_stmt 0 view .LVU109
 429 0006 8238      		cpi r24,lo8(-126)
 430 0008 01F4      		brne .L20
 816:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 817:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 818:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 431               		.loc 1 818 9 is_stmt 1 view .LVU110
 432               		.loc 1 818 15 is_stmt 0 view .LVU111
 433 000a 0E94 0000 		call host_keyboard_leds
 434               	.LVL40:
 435               		.loc 1 818 12 view .LVU112
 436 000e 81FF      		sbrs r24,1
 437 0010 00C0      		rjmp .L17
 819:tmk_core/common/action.c **** #    endif
 820:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 438               		.loc 1 820 9 is_stmt 1 view .LVU113
 439 0012 89E3      		ldi r24,lo8(57)
 440 0014 0E94 0000 		call add_key
 441               	.LVL41:
 821:tmk_core/common/action.c ****         send_keyboard_report();
 442               		.loc 1 821 9 view .LVU114
 443 0018 0E94 0000 		call send_keyboard_report
 444               	.LVL42:
 822:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 445               		.loc 1 822 9 view .LVU115
 446 001c 89E3      		ldi r24,lo8(57)
 447               	.L37:
 823:tmk_core/common/action.c ****         send_keyboard_report();
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c **** 
 826:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 827:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 828:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 829:tmk_core/common/action.c **** #    endif
 830:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 831:tmk_core/common/action.c ****         send_keyboard_report();
 832:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 448               		.loc 1 832 9 is_stmt 0 view .LVU116
 449 001e 0E94 0000 		call del_key
 450               	.LVL43:
 451               	.L38:
 833:tmk_core/common/action.c ****         send_keyboard_report();
 452               		.loc 1 833 9 is_stmt 1 view .LVU117
 453 0022 0C94 0000 		jmp send_keyboard_report
 454               	.LVL44:
 455               	.L20:
 826:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 456               		.loc 1 826 10 view .LVU118
 826:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 457               		.loc 1 826 13 is_stmt 0 view .LVU119
 458 0026 8338      		cpi r24,lo8(-125)
 459 0028 01F4      		brne .L22
 828:tmk_core/common/action.c **** #    endif
 460               		.loc 1 828 9 is_stmt 1 view .LVU120
 828:tmk_core/common/action.c **** #    endif
 461               		.loc 1 828 15 is_stmt 0 view .LVU121
 462 002a 0E94 0000 		call host_keyboard_leds
 463               	.LVL45:
 828:tmk_core/common/action.c **** #    endif
 464               		.loc 1 828 12 view .LVU122
 465 002e 80FF      		sbrs r24,0
 466 0030 00C0      		rjmp .L17
 830:tmk_core/common/action.c ****         send_keyboard_report();
 467               		.loc 1 830 9 is_stmt 1 view .LVU123
 468 0032 83E5      		ldi r24,lo8(83)
 469 0034 0E94 0000 		call add_key
 470               	.LVL46:
 831:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 471               		.loc 1 831 9 view .LVU124
 472 0038 0E94 0000 		call send_keyboard_report
 473               	.LVL47:
 832:tmk_core/common/action.c ****         send_keyboard_report();
 474               		.loc 1 832 9 view .LVU125
 475 003c 83E5      		ldi r24,lo8(83)
 476 003e 00C0      		rjmp .L37
 477               	.LVL48:
 478               	.L22:
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** 
 836:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 479               		.loc 1 836 10 view .LVU126
 480               		.loc 1 836 13 is_stmt 0 view .LVU127
 481 0040 8438      		cpi r24,lo8(-124)
 482 0042 01F4      		brne .L23
 837:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 838:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 483               		.loc 1 838 9 is_stmt 1 view .LVU128
 484               		.loc 1 838 15 is_stmt 0 view .LVU129
 485 0044 0E94 0000 		call host_keyboard_leds
 486               	.LVL49:
 487               		.loc 1 838 12 view .LVU130
 488 0048 82FF      		sbrs r24,2
 489 004a 00C0      		rjmp .L17
 839:tmk_core/common/action.c **** #    endif
 840:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 490               		.loc 1 840 9 is_stmt 1 view .LVU131
 491 004c 87E4      		ldi r24,lo8(71)
 492 004e 0E94 0000 		call add_key
 493               	.LVL50:
 841:tmk_core/common/action.c ****         send_keyboard_report();
 494               		.loc 1 841 9 view .LVU132
 495 0052 0E94 0000 		call send_keyboard_report
 496               	.LVL51:
 842:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 497               		.loc 1 842 9 view .LVU133
 498 0056 87E4      		ldi r24,lo8(71)
 499 0058 00C0      		rjmp .L37
 500               	.LVL52:
 501               	.L23:
 843:tmk_core/common/action.c ****         send_keyboard_report();
 844:tmk_core/common/action.c ****     }
 845:tmk_core/common/action.c **** #endif
 846:tmk_core/common/action.c **** 
 847:tmk_core/common/action.c ****     else if
 502               		.loc 1 847 10 view .LVU134
 848:tmk_core/common/action.c ****         IS_KEY(code) {
 503               		.loc 1 848 9 is_stmt 0 view .LVU135
 504 005a 9CEF      		ldi r25,lo8(-4)
 505 005c 980F      		add r25,r24
 506 005e 913A      		cpi r25,lo8(-95)
 507 0060 00F0      		brlo .L37
 849:tmk_core/common/action.c ****             del_key(code);
 850:tmk_core/common/action.c ****             send_keyboard_report();
 851:tmk_core/common/action.c ****         }
 852:tmk_core/common/action.c ****     else if
 508               		.loc 1 852 10 is_stmt 1 view .LVU136
 853:tmk_core/common/action.c ****         IS_MOD(code) {
 509               		.loc 1 853 9 is_stmt 0 view .LVU137
 510 0062 90E2      		ldi r25,lo8(32)
 511 0064 980F      		add r25,r24
 512 0066 9830      		cpi r25,lo8(8)
 513 0068 00F4      		brsh .L25
 854:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 514               		.loc 1 854 13 is_stmt 1 view .LVU138
 515               		.loc 1 854 22 is_stmt 0 view .LVU139
 516 006a 8770      		andi r24,lo8(7)
 517               	.LVL53:
 518               		.loc 1 854 13 view .LVU140
 519 006c 91E0      		ldi r25,lo8(1)
 520 006e 00C0      		rjmp 2f
 521               		1:
 522 0070 990F      		lsl r25
 523               		2:
 524 0072 8A95      		dec r24
 525 0074 02F4      		brpl 1b
 526 0076 892F      		mov r24,r25
 527 0078 0E94 0000 		call del_mods
 528               	.LVL54:
 855:tmk_core/common/action.c ****             send_keyboard_report();
 529               		.loc 1 855 13 is_stmt 1 view .LVU141
 530 007c 00C0      		rjmp .L38
 531               	.LVL55:
 532               	.L25:
 856:tmk_core/common/action.c ****         }
 857:tmk_core/common/action.c ****     else if
 533               		.loc 1 857 10 view .LVU142
 858:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 534               		.loc 1 858 9 is_stmt 0 view .LVU143
 535 007e 9BE5      		ldi r25,lo8(91)
 536 0080 980F      		add r25,r24
 537 0082 9330      		cpi r25,lo8(3)
 538 0084 00F4      		brsh .L26
 539               		.loc 1 858 27 is_stmt 1 discriminator 1 view .LVU144
 540 0086 90E0      		ldi r25,0
 541 0088 80E0      		ldi r24,0
 542               	.LVL56:
 543               		.loc 1 858 27 is_stmt 0 discriminator 1 view .LVU145
 544 008a 0C94 0000 		jmp host_system_send
 545               	.LVL57:
 546               	.L26:
 859:tmk_core/common/action.c ****     else if
 547               		.loc 1 859 10 is_stmt 1 view .LVU146
 860:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 548               		.loc 1 860 9 is_stmt 0 view .LVU147
 549 008e 98E5      		ldi r25,lo8(88)
 550 0090 980F      		add r25,r24
 551 0092 9731      		cpi r25,lo8(23)
 552 0094 00F4      		brsh .L27
 553               		.loc 1 860 29 is_stmt 1 discriminator 1 view .LVU148
 554 0096 90E0      		ldi r25,0
 555 0098 80E0      		ldi r24,0
 556               	.LVL58:
 557               		.loc 1 860 29 is_stmt 0 discriminator 1 view .LVU149
 558 009a 0C94 0000 		jmp host_consumer_send
 559               	.LVL59:
 560               	.L27:
 861:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 862:tmk_core/common/action.c ****     else if
 561               		.loc 1 862 10 is_stmt 1 view .LVU150
 863:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 562               		.loc 1 863 9 is_stmt 0 view .LVU151
 563 009e 803F      		cpi r24,lo8(-16)
 564 00a0 00F0      		brlo .L17
 864:tmk_core/common/action.c ****             mousekey_off(code);
 565               		.loc 1 864 13 is_stmt 1 view .LVU152
 566 00a2 0E94 0000 		call mousekey_off
 567               	.LVL60:
 865:tmk_core/common/action.c ****             mousekey_send();
 568               		.loc 1 865 13 view .LVU153
 569 00a6 0C94 0000 		jmp mousekey_send
 570               	.LVL61:
 571               	.L17:
 572               	/* epilogue start */
 866:tmk_core/common/action.c ****         }
 867:tmk_core/common/action.c **** #endif
 868:tmk_core/common/action.c **** }
 573               		.loc 1 868 1 is_stmt 0 view .LVU154
 574 00aa 0895      		ret
 575               		.cfi_endproc
 576               	.LFE110:
 578               		.section	.text.tap_code,"ax",@progbits
 579               	.global	tap_code
 581               	tap_code:
 582               	.LVL62:
 583               	.LFB111:
 869:tmk_core/common/action.c **** 
 870:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 871:tmk_core/common/action.c ****  *
 872:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 873:tmk_core/common/action.c ****  */
 874:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 584               		.loc 1 874 29 is_stmt 1 view -0
 585               		.cfi_startproc
 586               		.loc 1 874 29 is_stmt 0 view .LVU156
 587 0000 CF93      		push r28
 588               	.LCFI4:
 589               		.cfi_def_cfa_offset 3
 590               		.cfi_offset 28, -2
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 593               	/* stack size = 1 */
 594               	.L__stack_usage = 1
 595 0002 C82F      		mov r28,r24
 875:tmk_core/common/action.c ****     register_code(code);
 596               		.loc 1 875 5 is_stmt 1 view .LVU157
 597 0004 0E94 0000 		call register_code
 598               	.LVL63:
 876:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 599               		.loc 1 876 5 view .LVU158
 600               		.loc 1 876 8 is_stmt 0 view .LVU159
 601 0008 C933      		cpi r28,lo8(57)
 602 000a 01F4      		brne .L41
 877:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 603               		.loc 1 877 9 is_stmt 1 view .LVU160
 604               	.LVL64:
 605               	.LBB40:
 606               	.LBI40:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 607               		.loc 2 166 1 view .LVU161
 608               	.LBB41:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 609               		.loc 2 168 2 view .LVU162
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 610               		.loc 2 172 2 view .LVU163
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 611               		.loc 2 173 2 view .LVU164
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 612               		.loc 2 174 2 view .LVU165
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 613               		.loc 2 184 3 view .LVU166
 614               		.loc 2 187 2 view .LVU167
 615 000c 2FEF      		ldi r18,lo8(255999)
 616 000e 87EE      		ldi r24,hi8(255999)
 617 0010 93E0      		ldi r25,hlo8(255999)
 618 0012 2150      	1:	subi r18,1
 619 0014 8040      		sbci r24,0
 620 0016 9040      		sbci r25,0
 621 0018 01F4      		brne 1b
 622 001a 00C0      		rjmp .
 623 001c 0000      		nop
 624               	.LVL65:
 625               	.L41:
 626               		.loc 2 187 2 is_stmt 0 view .LVU168
 627               	.LBE41:
 628               	.LBE40:
 878:tmk_core/common/action.c ****     } else {
 879:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 880:tmk_core/common/action.c ****     }
 881:tmk_core/common/action.c ****     unregister_code(code);
 629               		.loc 1 881 5 is_stmt 1 view .LVU169
 630 001e 8C2F      		mov r24,r28
 631               	/* epilogue start */
 882:tmk_core/common/action.c **** }
 632               		.loc 1 882 1 is_stmt 0 view .LVU170
 633 0020 CF91      		pop r28
 634               	.LVL66:
 881:tmk_core/common/action.c **** }
 635               		.loc 1 881 5 view .LVU171
 636 0022 0C94 0000 		jmp unregister_code
 637               	.LVL67:
 881:tmk_core/common/action.c **** }
 638               		.loc 1 881 5 view .LVU172
 639               		.cfi_endproc
 640               	.LFE111:
 642               		.section	.text.register_mods,"ax",@progbits
 643               	.global	register_mods
 645               	register_mods:
 646               	.LVL68:
 647               	.LFB112:
 883:tmk_core/common/action.c **** 
 884:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 885:tmk_core/common/action.c ****  *
 886:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 887:tmk_core/common/action.c ****  */
 888:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 648               		.loc 1 888 34 is_stmt 1 view -0
 649               		.cfi_startproc
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 0 */
 653               	.L__stack_usage = 0
 889:tmk_core/common/action.c ****     if (mods) {
 654               		.loc 1 889 5 view .LVU174
 655               		.loc 1 889 8 is_stmt 0 view .LVU175
 656 0000 8823      		tst r24
 657 0002 01F0      		breq .L42
 890:tmk_core/common/action.c ****         add_mods(mods);
 658               		.loc 1 890 9 is_stmt 1 view .LVU176
 659 0004 0E94 0000 		call add_mods
 660               	.LVL69:
 891:tmk_core/common/action.c ****         send_keyboard_report();
 661               		.loc 1 891 9 view .LVU177
 662 0008 0C94 0000 		jmp send_keyboard_report
 663               	.LVL70:
 664               	.L42:
 665               	/* epilogue start */
 892:tmk_core/common/action.c ****     }
 893:tmk_core/common/action.c **** }
 666               		.loc 1 893 1 is_stmt 0 view .LVU178
 667 000c 0895      		ret
 668               		.cfi_endproc
 669               	.LFE112:
 671               		.section	.text.unregister_mods,"ax",@progbits
 672               	.global	unregister_mods
 674               	unregister_mods:
 675               	.LVL71:
 676               	.LFB113:
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 896:tmk_core/common/action.c ****  *
 897:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 898:tmk_core/common/action.c ****  */
 899:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 677               		.loc 1 899 36 is_stmt 1 view -0
 678               		.cfi_startproc
 679               	/* prologue: function */
 680               	/* frame size = 0 */
 681               	/* stack size = 0 */
 682               	.L__stack_usage = 0
 900:tmk_core/common/action.c ****     if (mods) {
 683               		.loc 1 900 5 view .LVU180
 684               		.loc 1 900 8 is_stmt 0 view .LVU181
 685 0000 8823      		tst r24
 686 0002 01F0      		breq .L44
 901:tmk_core/common/action.c ****         del_mods(mods);
 687               		.loc 1 901 9 is_stmt 1 view .LVU182
 688 0004 0E94 0000 		call del_mods
 689               	.LVL72:
 902:tmk_core/common/action.c ****         send_keyboard_report();
 690               		.loc 1 902 9 view .LVU183
 691 0008 0C94 0000 		jmp send_keyboard_report
 692               	.LVL73:
 693               	.L44:
 694               	/* epilogue start */
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** }
 695               		.loc 1 904 1 is_stmt 0 view .LVU184
 696 000c 0895      		ret
 697               		.cfi_endproc
 698               	.LFE113:
 700               		.section	.text.process_action,"ax",@progbits
 701               	.global	process_action
 703               	process_action:
 704               	.LVL74:
 705               	.LFB108:
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 706               		.loc 1 206 59 is_stmt 1 view -0
 707               		.cfi_startproc
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 708               		.loc 1 206 59 is_stmt 0 view .LVU186
 709 0000 BF92      		push r11
 710               	.LCFI5:
 711               		.cfi_def_cfa_offset 3
 712               		.cfi_offset 11, -2
 713 0002 CF92      		push r12
 714               	.LCFI6:
 715               		.cfi_def_cfa_offset 4
 716               		.cfi_offset 12, -3
 717 0004 DF92      		push r13
 718               	.LCFI7:
 719               		.cfi_def_cfa_offset 5
 720               		.cfi_offset 13, -4
 721 0006 EF92      		push r14
 722               	.LCFI8:
 723               		.cfi_def_cfa_offset 6
 724               		.cfi_offset 14, -5
 725 0008 FF92      		push r15
 726               	.LCFI9:
 727               		.cfi_def_cfa_offset 7
 728               		.cfi_offset 15, -6
 729 000a 0F93      		push r16
 730               	.LCFI10:
 731               		.cfi_def_cfa_offset 8
 732               		.cfi_offset 16, -7
 733 000c 1F93      		push r17
 734               	.LCFI11:
 735               		.cfi_def_cfa_offset 9
 736               		.cfi_offset 17, -8
 737 000e CF93      		push r28
 738               	.LCFI12:
 739               		.cfi_def_cfa_offset 10
 740               		.cfi_offset 28, -9
 741 0010 DF93      		push r29
 742               	.LCFI13:
 743               		.cfi_def_cfa_offset 11
 744               		.cfi_offset 29, -10
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 9 */
 748               	.L__stack_usage = 9
 749 0012 6C01      		movw r12,r24
 750 0014 D62F      		mov r29,r22
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 751               		.loc 1 206 59 view .LVU187
 752 0016 C72F      		mov r28,r23
 207:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 753               		.loc 1 207 5 is_stmt 1 view .LVU188
 754               	.LVL75:
 209:tmk_core/common/action.c **** #endif
 755               		.loc 1 209 5 view .LVU189
 209:tmk_core/common/action.c **** #endif
 756               		.loc 1 209 36 is_stmt 0 view .LVU190
 757 0018 FC01      		movw r30,r24
 758 001a 0581      		ldd r16,Z+5
 759 001c 0295      		swap r16
 760 001e 0F70      		andi r16,lo8(15)
 761               	.LVL76:
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 762               		.loc 1 212 5 is_stmt 1 view .LVU191
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 763               		.loc 1 212 14 is_stmt 0 view .LVU192
 764 0020 1281      		ldd r17,Z+2
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 765               		.loc 1 212 8 view .LVU193
 766 0022 1111      		cpse r17,__zero_reg__
 214:tmk_core/common/action.c ****     }
 767               		.loc 1 214 9 is_stmt 1 view .LVU194
 768 0024 0E94 0000 		call clear_weak_mods
 769               	.LVL77:
 770               	.L47:
 218:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 771               		.loc 1 218 5 view .LVU195
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 772               		.loc 1 220 5 view .LVU196
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 773               		.loc 1 220 9 is_stmt 0 view .LVU197
 774 0028 0E94 0000 		call is_oneshot_layer_active
 775               	.LVL78:
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 776               		.loc 1 220 9 view .LVU198
 777 002c E82E      		mov r14,r24
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 778               		.loc 1 220 8 view .LVU199
 779 002e 8823      		tst r24
 780 0030 01F0      		breq .L48
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 781               		.loc 1 220 35 discriminator 1 view .LVU200
 782 0032 1123      		tst r17
 783 0034 01F0      		breq .L131
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 784               		.loc 1 220 55 discriminator 2 view .LVU201
 785 0036 80E2      		ldi r24,lo8(32)
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 786               		.loc 1 220 55 discriminator 2 view .LVU202
 787 0038 8D0F      		add r24,r29
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 788               		.loc 1 220 52 discriminator 2 view .LVU203
 789 003a 8830      		cpi r24,lo8(8)
 790 003c 00F0      		brlo .L131
 221:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 791               		.loc 1 221 9 is_stmt 1 view .LVU204
 792 003e 82E0      		ldi r24,lo8(2)
 793 0040 0E94 0000 		call clear_oneshot_layer_state
 794               	.LVL79:
 222:tmk_core/common/action.c ****     }
 795               		.loc 1 222 9 view .LVU205
 222:tmk_core/common/action.c ****     }
 796               		.loc 1 222 31 is_stmt 0 view .LVU206
 797 0044 0E94 0000 		call is_oneshot_layer_active
 798               	.LVL80:
 222:tmk_core/common/action.c ****     }
 799               		.loc 1 222 9 view .LVU207
 800 0048 91E0      		ldi r25,lo8(1)
 801 004a E82E      		mov r14,r24
 802 004c E926      		eor r14,r25
 803               	.LVL81:
 804               	.L48:
 226:tmk_core/common/action.c ****         /* Key and Mods */
 805               		.loc 1 226 5 is_stmt 1 view .LVU208
 226:tmk_core/common/action.c ****         /* Key and Mods */
 806               		.loc 1 226 24 is_stmt 0 view .LVU209
 807 004e BC2E      		mov r11,r28
 808 0050 B294      		swap r11
 809 0052 9FE0      		ldi r25,lo8(15)
 810 0054 B922      		and r11,r25
 226:tmk_core/common/action.c ****         /* Key and Mods */
 811               		.loc 1 226 5 view .LVU210
 812 0056 EB2D      		mov r30,r11
 813 0058 F0E0      		ldi r31,0
 814 005a E050      		subi r30,lo8(-(gs(.L51)))
 815 005c F040      		sbci r31,hi8(-(gs(.L51)))
 816 005e 0C94 0000 		jmp __tablejump2__
 817               		.section	.jumptables.gcc.process_action,"a",@progbits
 818               		.p2align	1
 819               	.L51:
 820 0000 0000      		.word gs(.L59)
 821 0002 0000      		.word gs(.L59)
 822 0004 0000      		.word gs(.L58)
 823 0006 0000      		.word gs(.L58)
 824 0008 0000      		.word gs(.L57)
 825 000a 0000      		.word gs(.L56)
 826 000c 0000      		.word gs(.L49)
 827 000e 0000      		.word gs(.L49)
 828 0010 0000      		.word gs(.L55)
 829 0012 0000      		.word gs(.L54)
 830 0014 0000      		.word gs(.L53)
 831 0016 0000      		.word gs(.L53)
 832 0018 0000      		.word gs(.L52)
 833 001a 0000      		.word gs(.L49)
 834 001c 0000      		.word gs(.L49)
 835 001e 0000      		.word gs(.L50)
 836               		.section	.text.process_action
 837               	.LVL82:
 838               	.L131:
 218:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 839               		.loc 1 218 10 view .LVU211
 840 0062 E12C      		mov r14,__zero_reg__
 841 0064 00C0      		rjmp .L48
 842               	.LVL83:
 843               	.L59:
 844               	.LBB42:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 845               		.loc 1 230 13 is_stmt 1 view .LVU212
 846 0066 0C2F      		mov r16,r28
 847               	.LVL84:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 848               		.loc 1 230 13 is_stmt 0 view .LVU213
 849 0068 0F70      		andi r16,lo8(15)
 230:tmk_core/common/action.c ****             if (event.pressed) {
 850               		.loc 1 230 44 view .LVU214
 851 006a C07F      		andi r28,lo8(-16)
 852               	.LVL85:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 853               		.loc 1 230 21 view .LVU215
 854 006c 01F0      		breq .L60
 230:tmk_core/common/action.c ****             if (event.pressed) {
 855               		.loc 1 230 21 discriminator 2 view .LVU216
 856 006e 0295      		swap r16
 857 0070 007F      		andi r16,lo8(-16)
 858               	.L60:
 859               	.LVL86:
 231:tmk_core/common/action.c ****                 if (mods) {
 860               		.loc 1 231 13 is_stmt 1 discriminator 4 view .LVU217
 231:tmk_core/common/action.c ****                 if (mods) {
 861               		.loc 1 231 16 is_stmt 0 discriminator 4 view .LVU218
 862 0072 1123      		tst r17
 863 0074 01F0      		breq .L61
 232:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 864               		.loc 1 232 17 is_stmt 1 view .LVU219
 232:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 865               		.loc 1 232 20 is_stmt 0 view .LVU220
 866 0076 0023      		tst r16
 867 0078 01F0      		breq .L163
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 868               		.loc 1 233 21 is_stmt 1 view .LVU221
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 869               		.loc 1 233 25 is_stmt 0 view .LVU222
 870 007a 80E2      		ldi r24,lo8(32)
 871 007c 8D0F      		add r24,r29
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 872               		.loc 1 233 24 view .LVU223
 873 007e 8830      		cpi r24,lo8(8)
 874 0080 00F0      		brlo .L63
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 875               		.loc 1 233 49 discriminator 1 view .LVU224
 876 0082 D111      		cpse r29,__zero_reg__
 877 0084 00C0      		rjmp .L64
 878               	.L63:
 237:tmk_core/common/action.c ****                     } else {
 879               		.loc 1 237 25 is_stmt 1 view .LVU225
 880 0086 802F      		mov r24,r16
 881 0088 0E94 0000 		call add_mods
 882               	.LVL87:
 883               	.L65:
 241:tmk_core/common/action.c ****                 }
 884               		.loc 1 241 21 view .LVU226
 885 008c 0E94 0000 		call send_keyboard_report
 886               	.LVL88:
 243:tmk_core/common/action.c ****             } else {
 887               		.loc 1 243 17 view .LVU227
 888               	.L163:
 243:tmk_core/common/action.c ****             } else {
 889               		.loc 1 243 17 is_stmt 0 view .LVU228
 890               	.LBE42:
 534:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 891               		.loc 1 534 75 is_stmt 1 view .LVU229
 535:tmk_core/common/action.c ****                         } else {
 892               		.loc 1 535 29 view .LVU230
 893 0090 8D2F      		mov r24,r29
 894 0092 0E94 0000 		call register_code
 895               	.LVL89:
 896 0096 00C0      		rjmp .L49
 897               	.LVL90:
 898               	.L64:
 899               	.LBB43:
 239:tmk_core/common/action.c ****                     }
 900               		.loc 1 239 25 view .LVU231
 901 0098 802F      		mov r24,r16
 902 009a 0E94 0000 		call add_weak_mods
 903               	.LVL91:
 904 009e 00C0      		rjmp .L65
 905               	.L61:
 245:tmk_core/common/action.c ****                 if (mods) {
 906               		.loc 1 245 17 view .LVU232
 907 00a0 8D2F      		mov r24,r29
 908 00a2 0E94 0000 		call unregister_code
 909               	.LVL92:
 246:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 910               		.loc 1 246 17 view .LVU233
 246:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 911               		.loc 1 246 20 is_stmt 0 view .LVU234
 912 00a6 0023      		tst r16
 913 00a8 01F0      		breq .L49
 247:tmk_core/common/action.c ****                         del_mods(mods);
 914               		.loc 1 247 21 is_stmt 1 view .LVU235
 247:tmk_core/common/action.c ****                         del_mods(mods);
 915               		.loc 1 247 25 is_stmt 0 view .LVU236
 916 00aa 80E2      		ldi r24,lo8(32)
 917 00ac 8D0F      		add r24,r29
 247:tmk_core/common/action.c ****                         del_mods(mods);
 918               		.loc 1 247 24 view .LVU237
 919 00ae 8830      		cpi r24,lo8(8)
 920 00b0 00F0      		brlo .L67
 247:tmk_core/common/action.c ****                         del_mods(mods);
 921               		.loc 1 247 49 discriminator 1 view .LVU238
 922 00b2 D111      		cpse r29,__zero_reg__
 923 00b4 00C0      		rjmp .L68
 924               	.L67:
 248:tmk_core/common/action.c ****                     } else {
 925               		.loc 1 248 25 is_stmt 1 view .LVU239
 926 00b6 802F      		mov r24,r16
 927 00b8 0E94 0000 		call del_mods
 928               	.LVL93:
 929               	.L69:
 252:tmk_core/common/action.c ****                 }
 930               		.loc 1 252 21 view .LVU240
 931 00bc 0E94 0000 		call send_keyboard_report
 932               	.LVL94:
 933               	.L49:
 252:tmk_core/common/action.c ****                 }
 934               		.loc 1 252 21 is_stmt 0 view .LVU241
 935               	.LBE43:
 667:tmk_core/common/action.c ****         case ACT_LAYER:
 936               		.loc 1 667 5 is_stmt 1 view .LVU242
 937 00c0 2B2D      		mov r18,r11
 938 00c2 2850      		subi r18,8
 939 00c4 330B      		sbc r19,r19
 940 00c6 2430      		cpi r18,4
 941 00c8 3105      		cpc r19,__zero_reg__
 942 00ca 00F4      		brsh .L126
 674:tmk_core/common/action.c ****             break;
 943               		.loc 1 674 13 view .LVU243
 944 00cc 0E94 0000 		call host_keyboard_leds
 945               	.LVL95:
 946 00d0 0E94 0000 		call led_set
 947               	.LVL96:
 675:tmk_core/common/action.c ****         default:
 948               		.loc 1 675 13 view .LVU244
 949               	.L126:
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 950               		.loc 1 709 5 view .LVU245
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 951               		.loc 1 709 8 is_stmt 0 view .LVU246
 952 00d4 EE20      		tst r14
 953 00d6 01F4      		brne .+2
 954 00d8 00C0      		rjmp .L46
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 955               		.loc 1 709 33 discriminator 1 view .LVU247
 956 00da 0E94 0000 		call get_oneshot_layer_state
 957               	.LVL97:
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 958               		.loc 1 709 28 discriminator 1 view .LVU248
 959 00de 80FD      		sbrc r24,0
 960 00e0 00C0      		rjmp .L46
 710:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 961               		.loc 1 710 9 is_stmt 1 view .LVU249
 710:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 962               		.loc 1 710 31 is_stmt 0 view .LVU250
 963 00e2 F601      		movw r30,r12
 964 00e4 1282      		std Z+2,__zero_reg__
 711:tmk_core/common/action.c ****         process_record(record);
 965               		.loc 1 711 9 is_stmt 1 view .LVU251
 966 00e6 0E94 0000 		call get_oneshot_layer
 967               	.LVL98:
 968 00ea 0E94 0000 		call layer_on
 969               	.LVL99:
 712:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 970               		.loc 1 712 9 view .LVU252
 971 00ee C601      		movw r24,r12
 972 00f0 0E94 0000 		call process_record
 973               	.LVL100:
 713:tmk_core/common/action.c ****     }
 974               		.loc 1 713 9 view .LVU253
 975 00f4 0E94 0000 		call get_oneshot_layer
 976               	.LVL101:
 977               	/* epilogue start */
 716:tmk_core/common/action.c **** 
 978               		.loc 1 716 1 is_stmt 0 view .LVU254
 979 00f8 DF91      		pop r29
 980               	.LVL102:
 716:tmk_core/common/action.c **** 
 981               		.loc 1 716 1 view .LVU255
 982 00fa CF91      		pop r28
 716:tmk_core/common/action.c **** 
 983               		.loc 1 716 1 view .LVU256
 984 00fc 1F91      		pop r17
 985 00fe 0F91      		pop r16
 986 0100 FF90      		pop r15
 987 0102 EF90      		pop r14
 988               	.LVL103:
 716:tmk_core/common/action.c **** 
 989               		.loc 1 716 1 view .LVU257
 990 0104 DF90      		pop r13
 991 0106 CF90      		pop r12
 992               	.LVL104:
 716:tmk_core/common/action.c **** 
 993               		.loc 1 716 1 view .LVU258
 994 0108 BF90      		pop r11
 713:tmk_core/common/action.c ****     }
 995               		.loc 1 713 9 view .LVU259
 996 010a 0C94 0000 		jmp layer_off
 997               	.LVL105:
 998               	.L68:
 999               	.LBB44:
 250:tmk_core/common/action.c ****                     }
 1000               		.loc 1 250 25 is_stmt 1 view .LVU260
 1001 010e 802F      		mov r24,r16
 1002 0110 0E94 0000 		call del_weak_mods
 1003               	.LVL106:
 1004 0114 00C0      		rjmp .L69
 1005               	.LVL107:
 1006               	.L58:
 250:tmk_core/common/action.c ****                     }
 1007               		.loc 1 250 25 is_stmt 0 view .LVU261
 1008               	.LBE44:
 1009               	.LBB45:
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1010               		.loc 1 259 13 is_stmt 1 view .LVU262
 1011 0116 FC2F      		mov r31,r28
 1012 0118 FF70      		andi r31,lo8(15)
 1013 011a FF2E      		mov r15,r31
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1014               		.loc 1 259 44 is_stmt 0 view .LVU263
 1015 011c C07F      		andi r28,lo8(-16)
 1016               	.LVL108:
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1017               		.loc 1 259 21 view .LVU264
 1018 011e C032      		cpi r28,lo8(32)
 1019 0120 01F0      		breq .L70
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1020               		.loc 1 259 21 discriminator 2 view .LVU265
 1021 0122 F294      		swap r15
 1022 0124 80EF      		ldi r24,lo8(-16)
 1023 0126 F822      		and r15,r24
 1024               	.L70:
 1025               	.LVL109:
 260:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1026               		.loc 1 260 13 is_stmt 1 discriminator 4 view .LVU266
 1027 0128 DD23      		tst r29
 1028 012a 01F0      		breq .L71
 1029 012c D130      		cpi r29,lo8(1)
 1030 012e 01F0      		breq .L72
 315:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1031               		.loc 1 315 21 view .LVU267
 315:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1032               		.loc 1 315 24 is_stmt 0 view .LVU268
 1033 0130 1123      		tst r17
 1034 0132 01F0      		breq .L80
 316:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1035               		.loc 1 316 25 is_stmt 1 view .LVU269
 316:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1036               		.loc 1 316 28 is_stmt 0 view .LVU270
 1037 0134 0023      		tst r16
 1038 0136 01F0      		breq .L81
 318:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1039               		.loc 1 318 29 is_stmt 1 view .LVU271
 322:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1040               		.loc 1 322 33 is_stmt 0 view .LVU272
 1041 0138 F601      		movw r30,r12
 1042 013a 8581      		ldd r24,Z+5
 318:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1043               		.loc 1 318 32 view .LVU273
 1044 013c 80FF      		sbrs r24,0
 1045 013e 00C0      		rjmp .L163
 323:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1046               		.loc 1 323 76 is_stmt 1 view .LVU274
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 1047               		.loc 1 325 33 view .LVU275
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 1048               		.loc 1 325 51 is_stmt 0 view .LVU276
 1049 0140 8F70      		andi r24,lo8(15)
 1050 0142 8583      		std Z+5,r24
 326:tmk_core/common/action.c ****                             } else
 1051               		.loc 1 326 33 is_stmt 1 view .LVU277
 1052 0144 00C0      		rjmp .L81
 1053               	.L71:
 264:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1054               		.loc 1 264 21 view .LVU278
 264:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1055               		.loc 1 264 24 is_stmt 0 view .LVU279
 1056 0146 1123      		tst r17
 1057 0148 01F0      		breq .L74
 265:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1058               		.loc 1 265 25 is_stmt 1 view .LVU280
 265:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1059               		.loc 1 265 28 is_stmt 0 view .LVU281
 1060 014a 0111      		cpse r16,__zero_reg__
 1061 014c 00C0      		rjmp .L75
 1062               	.L76:
 279:tmk_core/common/action.c ****                         }
 1063               		.loc 1 279 29 is_stmt 1 view .LVU282
 279:tmk_core/common/action.c ****                         }
 1064               		.loc 1 279 50 is_stmt 0 view .LVU283
 1065 014e 0E94 0000 		call get_oneshot_mods
 1066               	.LVL110:
 279:tmk_core/common/action.c ****                         }
 1067               		.loc 1 279 29 view .LVU284
 1068 0152 8F29      		or r24,r15
 1069               	.LVL111:
 1070               	.L162:
 279:tmk_core/common/action.c ****                         }
 1071               		.loc 1 279 29 view .LVU285
 1072               	.LBE45:
 461:tmk_core/common/action.c ****             } else {
 1073               		.loc 1 461 17 view .LVU286
 1074 0154 0E94 0000 		call register_mods
 1075               	.LVL112:
 1076 0158 00C0      		rjmp .L49
 1077               	.LVL113:
 1078               	.L75:
 1079               	.LBB48:
 268:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1080               		.loc 1 268 32 is_stmt 1 view .LVU287
 268:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1081               		.loc 1 268 35 is_stmt 0 view .LVU288
 1082 015a 0130      		cpi r16,lo8(1)
 1083 015c 01F4      		brne .L76
 269:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1084               		.loc 1 269 65 is_stmt 1 view .LVU289
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1085               		.loc 1 270 29 view .LVU290
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1086               		.loc 1 270 53 is_stmt 0 view .LVU291
 1087 015e 0E94 0000 		call get_oneshot_mods
 1088               	.LVL114:
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1089               		.loc 1 270 29 view .LVU292
 1090 0162 8F29      		or r24,r15
 1091 0164 0E94 0000 		call set_oneshot_mods
 1092               	.LVL115:
 1093 0168 00C0      		rjmp .L49
 1094               	.L74:
 282:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1095               		.loc 1 282 25 is_stmt 1 view .LVU293
 282:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1096               		.loc 1 282 28 is_stmt 0 view .LVU294
 1097 016a 0111      		cpse r16,__zero_reg__
 1098 016c 00C0      		rjmp .L77
 1099               	.L165:
 297:tmk_core/common/action.c ****                             unregister_mods(mods);
 1100               		.loc 1 297 29 is_stmt 1 view .LVU295
 1101 016e 0E94 0000 		call clear_oneshot_mods
 1102               	.LVL116:
 298:tmk_core/common/action.c ****                         }
 1103               		.loc 1 298 29 view .LVU296
 1104               	.L83:
 345:tmk_core/common/action.c ****                             unregister_mods(mods);
 1105               		.loc 1 345 67 view .LVU297
 346:tmk_core/common/action.c ****                         }
 1106               		.loc 1 346 29 view .LVU298
 1107 0172 8F2D      		mov r24,r15
 1108 0174 0E94 0000 		call unregister_mods
 1109               	.LVL117:
 1110 0178 00C0      		rjmp .L49
 1111               	.L77:
 285:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1112               		.loc 1 285 32 view .LVU299
 285:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1113               		.loc 1 285 35 is_stmt 0 view .LVU300
 1114 017a 0130      		cpi r16,lo8(1)
 1115 017c 01F4      		brne .+2
 1116 017e 00C0      		rjmp .L49
 1117 0180 00C0      		rjmp .L165
 1118               	.L72:
 304:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1119               		.loc 1 304 21 is_stmt 1 view .LVU301
 304:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1120               		.loc 1 304 24 is_stmt 0 view .LVU302
 1121 0182 1123      		tst r17
 1122 0184 01F0      		breq .L79
 305:tmk_core/common/action.c ****                             register_mods(mods);
 1123               		.loc 1 305 25 is_stmt 1 view .LVU303
 305:tmk_core/common/action.c ****                             register_mods(mods);
 1124               		.loc 1 305 28 is_stmt 0 view .LVU304
 1125 0186 0630      		cpi r16,lo8(6)
 1126 0188 00F0      		brlo .+2
 1127 018a 00C0      		rjmp .L49
 1128               	.L81:
 334:tmk_core/common/action.c ****                             register_mods(mods);
 1129               		.loc 1 334 67 is_stmt 1 view .LVU305
 335:tmk_core/common/action.c ****                         }
 1130               		.loc 1 335 29 view .LVU306
 1131 018c 8F2D      		mov r24,r15
 1132 018e 00C0      		rjmp .L162
 1133               	.L79:
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 1134               		.loc 1 309 25 view .LVU307
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 1135               		.loc 1 309 28 is_stmt 0 view .LVU308
 1136 0190 0530      		cpi r16,lo8(5)
 1137 0192 00F0      		brlo .+2
 1138 0194 00C0      		rjmp .L49
 1139 0196 00C0      		rjmp .L83
 1140               	.L80:
 338:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1141               		.loc 1 338 25 is_stmt 1 view .LVU309
 338:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1142               		.loc 1 338 28 is_stmt 0 view .LVU310
 1143 0198 0023      		tst r16
 1144 019a 01F0      		breq .L83
 339:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1145               		.loc 1 339 71 is_stmt 1 view .LVU311
 340:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1146               		.loc 1 340 29 view .LVU312
 340:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1147               		.loc 1 340 32 is_stmt 0 view .LVU313
 1148 019c D933      		cpi r29,lo8(57)
 1149 019e 01F4      		brne .L125
 341:tmk_core/common/action.c ****                             }
 1150               		.loc 1 341 33 is_stmt 1 view .LVU314
 1151               	.LVL118:
 1152               	.LBB46:
 1153               	.LBI46:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1154               		.loc 2 166 1 view .LVU315
 1155               	.LBB47:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1156               		.loc 2 168 2 view .LVU316
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1157               		.loc 2 172 2 view .LVU317
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1158               		.loc 2 173 2 view .LVU318
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1159               		.loc 2 174 2 view .LVU319
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1160               		.loc 2 184 3 view .LVU320
 1161               		.loc 2 187 2 view .LVU321
 1162 01a0 FFEF      		ldi r31,lo8(255999)
 1163 01a2 27EE      		ldi r18,hi8(255999)
 1164 01a4 33E0      		ldi r19,hlo8(255999)
 1165 01a6 F150      	1:	subi r31,1
 1166 01a8 2040      		sbci r18,0
 1167 01aa 3040      		sbci r19,0
 1168 01ac 01F4      		brne 1b
 1169               	.LVL119:
 1170               	.L166:
 1171               		.loc 2 187 2 is_stmt 0 view .LVU322
 1172               	.LBE47:
 1173               	.LBE46:
 1174               	.LBE48:
 1175               	.LBB49:
 1176               	.LBB50:
 1177 01ae 00C0      		rjmp .
 1178 01b0 0000      		nop
 1179               	.L125:
 1180               	.LBE50:
 1181               	.LBE49:
 548:tmk_core/common/action.c ****                         } else {
 1182               		.loc 1 548 29 is_stmt 1 view .LVU323
 1183 01b2 8D2F      		mov r24,r29
 1184 01b4 0E94 0000 		call unregister_code
 1185               	.LVL120:
 1186 01b8 00C0      		rjmp .L49
 1187               	.L57:
 356:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1188               		.loc 1 356 13 view .LVU324
 356:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1189               		.loc 1 356 33 is_stmt 0 view .LVU325
 1190 01ba 8C2F      		mov r24,r28
 1191 01bc 8695      		lsr r24
 1192 01be 8695      		lsr r24
 1193 01c0 8370      		andi r24,lo8(3)
 1194 01c2 01F0      		breq .L85
 1195 01c4 8130      		cpi r24,lo8(1)
 1196 01c6 01F0      		breq .+2
 1197 01c8 00C0      		rjmp .L49
 365:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1198               		.loc 1 365 21 is_stmt 1 view .LVU326
 366:tmk_core/common/action.c ****                     } else {
 1199               		.loc 1 366 25 is_stmt 0 view .LVU327
 1200 01ca 8D2F      		mov r24,r29
 1201 01cc 9C2F      		mov r25,r28
 1202 01ce 9370      		andi r25,lo8(3)
 365:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1203               		.loc 1 365 24 view .LVU328
 1204 01d0 1111      		cpse r17,__zero_reg__
 1205 01d2 00C0      		rjmp .L164
 368:tmk_core/common/action.c ****                     }
 1206               		.loc 1 368 25 is_stmt 1 view .LVU329
 1207 01d4 90E0      		ldi r25,0
 1208 01d6 80E0      		ldi r24,0
 1209               	.L164:
 1210 01d8 0E94 0000 		call host_consumer_send
 1211               	.LVL121:
 1212 01dc 00C0      		rjmp .L49
 1213               	.L85:
 358:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1214               		.loc 1 358 21 view .LVU330
 359:tmk_core/common/action.c ****                     } else {
 1215               		.loc 1 359 25 is_stmt 0 view .LVU331
 1216 01de 8D2F      		mov r24,r29
 1217 01e0 9C2F      		mov r25,r28
 1218 01e2 9370      		andi r25,lo8(3)
 358:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1219               		.loc 1 358 24 view .LVU332
 1220 01e4 1111      		cpse r17,__zero_reg__
 1221 01e6 00C0      		rjmp .L159
 361:tmk_core/common/action.c ****                     }
 1222               		.loc 1 361 25 is_stmt 1 view .LVU333
 1223 01e8 90E0      		ldi r25,0
 1224 01ea 80E0      		ldi r24,0
 1225               	.L159:
 1226 01ec 0E94 0000 		call host_system_send
 1227               	.LVL122:
 1228 01f0 00C0      		rjmp .L49
 1229               	.L56:
 377:tmk_core/common/action.c ****                 switch (action.key.code) {
 1230               		.loc 1 377 13 view .LVU334
 377:tmk_core/common/action.c ****                 switch (action.key.code) {
 1231               		.loc 1 377 16 is_stmt 0 view .LVU335
 1232 01f2 1123      		tst r17
 1233 01f4 01F0      		breq .L89
 378:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1234               		.loc 1 378 17 is_stmt 1 view .LVU336
 1235 01f6 D53F      		cpi r29,lo8(-11)
 1236 01f8 01F0      		breq .L90
 1237 01fa D63F      		cpi r29,lo8(-10)
 1238 01fc 01F0      		breq .L91
 1239 01fe D43F      		cpi r29,lo8(-12)
 1240 0200 01F4      		brne .L92
 380:tmk_core/common/action.c ****                         break;
 1241               		.loc 1 380 25 view .LVU337
 380:tmk_core/common/action.c ****                         break;
 1242               		.loc 1 380 36 is_stmt 0 view .LVU338
 1243 0202 8091 0000 		lds r24,tp_buttons
 1244 0206 9091 0000 		lds r25,tp_buttons+1
 1245 020a 8160      		ori r24,1
 1246               	.L156:
 386:tmk_core/common/action.c ****                         break;
 1247               		.loc 1 386 36 view .LVU339
 1248 020c 9093 0000 		sts tp_buttons+1,r25
 1249 0210 8093 0000 		sts tp_buttons,r24
 387:tmk_core/common/action.c ****                     default:
 1250               		.loc 1 387 25 is_stmt 1 view .LVU340
 1251               	.L92:
 391:tmk_core/common/action.c ****                 mousekey_send();
 1252               		.loc 1 391 17 view .LVU341
 1253 0214 8D2F      		mov r24,r29
 1254 0216 0E94 0000 		call mousekey_on
 1255               	.LVL123:
 392:tmk_core/common/action.c ****             } else {
 1256               		.loc 1 392 17 view .LVU342
 1257               	.L160:
 408:tmk_core/common/action.c ****             }
 1258               		.loc 1 408 17 view .LVU343
 1259 021a 0E94 0000 		call mousekey_send
 1260               	.LVL124:
 1261 021e 00C0      		rjmp .L49
 1262               	.L90:
 383:tmk_core/common/action.c ****                         break;
 1263               		.loc 1 383 25 view .LVU344
 383:tmk_core/common/action.c ****                         break;
 1264               		.loc 1 383 36 is_stmt 0 view .LVU345
 1265 0220 8091 0000 		lds r24,tp_buttons
 1266 0224 9091 0000 		lds r25,tp_buttons+1
 1267 0228 8260      		ori r24,2
 1268 022a 00C0      		rjmp .L156
 1269               	.L91:
 386:tmk_core/common/action.c ****                         break;
 1270               		.loc 1 386 25 is_stmt 1 view .LVU346
 386:tmk_core/common/action.c ****                         break;
 1271               		.loc 1 386 36 is_stmt 0 view .LVU347
 1272 022c 8091 0000 		lds r24,tp_buttons
 1273 0230 9091 0000 		lds r25,tp_buttons+1
 1274 0234 8460      		ori r24,4
 1275 0236 00C0      		rjmp .L156
 1276               	.L89:
 394:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1277               		.loc 1 394 17 is_stmt 1 view .LVU348
 1278 0238 D53F      		cpi r29,lo8(-11)
 1279 023a 01F0      		breq .L93
 1280 023c D63F      		cpi r29,lo8(-10)
 1281 023e 01F0      		breq .L94
 1282 0240 D43F      		cpi r29,lo8(-12)
 1283 0242 01F4      		brne .L95
 396:tmk_core/common/action.c ****                         break;
 1284               		.loc 1 396 25 view .LVU349
 396:tmk_core/common/action.c ****                         break;
 1285               		.loc 1 396 36 is_stmt 0 view .LVU350
 1286 0244 8091 0000 		lds r24,tp_buttons
 1287 0248 9091 0000 		lds r25,tp_buttons+1
 1288 024c 8E7F      		andi r24,254
 1289               	.L157:
 402:tmk_core/common/action.c ****                         break;
 1290               		.loc 1 402 36 view .LVU351
 1291 024e 9093 0000 		sts tp_buttons+1,r25
 1292 0252 8093 0000 		sts tp_buttons,r24
 403:tmk_core/common/action.c ****                     default:
 1293               		.loc 1 403 25 is_stmt 1 view .LVU352
 1294               	.L95:
 407:tmk_core/common/action.c ****                 mousekey_send();
 1295               		.loc 1 407 17 view .LVU353
 1296 0256 8D2F      		mov r24,r29
 1297 0258 0E94 0000 		call mousekey_off
 1298               	.LVL125:
 1299 025c 00C0      		rjmp .L160
 1300               	.L93:
 399:tmk_core/common/action.c ****                         break;
 1301               		.loc 1 399 25 view .LVU354
 399:tmk_core/common/action.c ****                         break;
 1302               		.loc 1 399 36 is_stmt 0 view .LVU355
 1303 025e 8091 0000 		lds r24,tp_buttons
 1304 0262 9091 0000 		lds r25,tp_buttons+1
 1305 0266 8D7F      		andi r24,253
 1306 0268 00C0      		rjmp .L157
 1307               	.L94:
 402:tmk_core/common/action.c ****                         break;
 1308               		.loc 1 402 25 is_stmt 1 view .LVU356
 402:tmk_core/common/action.c ****                         break;
 1309               		.loc 1 402 36 is_stmt 0 view .LVU357
 1310 026a 8091 0000 		lds r24,tp_buttons
 1311 026e 9091 0000 		lds r25,tp_buttons+1
 1312 0272 8B7F      		andi r24,251
 1313 0274 00C0      		rjmp .L157
 1314               	.L55:
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1315               		.loc 1 414 13 is_stmt 1 view .LVU358
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1316               		.loc 1 414 39 is_stmt 0 view .LVU359
 1317 0276 8C2F      		mov r24,r28
 1318 0278 8370      		andi r24,lo8(3)
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1319               		.loc 1 414 16 view .LVU360
 1320 027a 01F0      		breq .+2
 1321 027c 00C0      		rjmp .L96
 416:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1322               		.loc 1 416 17 is_stmt 1 view .LVU361
 416:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1323               		.loc 1 416 20 is_stmt 0 view .LVU362
 1324 027e 1111      		cpse r17,__zero_reg__
 1325 0280 00C0      		rjmp .L49
 1326               	.LBB52:
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1327               		.loc 1 417 21 is_stmt 1 view .LVU363
 1328               	.LVL126:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1329               		.loc 1 418 21 view .LVU364
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1330               		.loc 1 417 61 is_stmt 0 view .LVU365
 1331 0282 4D2F      		mov r20,r29
 1332 0284 4295      		swap r20
 1333 0286 4695      		lsr r20
 1334 0288 4770      		andi r20,lo8(7)
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1335               		.loc 1 417 35 view .LVU366
 1336 028a 440F      		lsl r20
 1337 028c 440F      		lsl r20
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1338               		.loc 1 418 77 view .LVU367
 1339 028e 0D2F      		mov r16,r29
 1340               	.LVL127:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1341               		.loc 1 418 77 view .LVU368
 1342 0290 0F70      		andi r16,lo8(15)
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1343               		.loc 1 418 44 view .LVU369
 1344 0292 10E0      		ldi r17,0
 1345               	.LVL128:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1346               		.loc 1 418 44 view .LVU370
 1347 0294 30E0      		ldi r19,0
 1348 0296 20E0      		ldi r18,0
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1349               		.loc 1 418 35 view .LVU371
 1350 0298 042E      		mov r0,r20
 1351 029a 00C0      		rjmp 2f
 1352               		1:
 1353 029c 000F      		lsl r16
 1354 029e 111F      		rol r17
 1355 02a0 221F      		rol r18
 1356 02a2 331F      		rol r19
 1357               		2:
 1358 02a4 0A94      		dec r0
 1359 02a6 02F4      		brpl 1b
 1360               	.LVL129:
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1361               		.loc 1 419 21 is_stmt 1 view .LVU372
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1362               		.loc 1 419 104 is_stmt 0 view .LVU373
 1363 02a8 60E0      		ldi r22,0
 1364 02aa 70E0      		ldi r23,0
 1365 02ac CB01      		movw r24,r22
 1366 02ae D4FF      		sbrs r29,4
 1367 02b0 00C0      		rjmp .L97
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1368               		.loc 1 419 94 discriminator 1 view .LVU374
 1369 02b2 6FE0      		ldi r22,lo8(15)
 1370 02b4 70E0      		ldi r23,0
 1371 02b6 80E0      		ldi r24,0
 1372 02b8 90E0      		ldi r25,0
 1373 02ba 00C0      		rjmp 2f
 1374               		1:
 1375 02bc 660F      		lsl r22
 1376 02be 771F      		rol r23
 1377 02c0 881F      		rol r24
 1378 02c2 991F      		rol r25
 1379               		2:
 1380 02c4 4A95      		dec r20
 1381 02c6 02F4      		brpl 1b
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1382               		.loc 1 419 104 discriminator 1 view .LVU375
 1383 02c8 6095      		com r22
 1384 02ca 7095      		com r23
 1385 02cc 8095      		com r24
 1386 02ce 9095      		com r25
 1387               	.L97:
 1388               	.LVL130:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1389               		.loc 1 420 21 is_stmt 1 discriminator 4 view .LVU376
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1390               		.loc 1 420 47 is_stmt 0 discriminator 4 view .LVU377
 1391 02d0 C695      		lsr r28
 1392 02d2 C695      		lsr r28
 1393               	.LVL131:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1394               		.loc 1 420 47 discriminator 4 view .LVU378
 1395 02d4 C370      		andi r28,lo8(3)
 1396 02d6 602B      		or r22,r16
 1397               	.LVL132:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1398               		.loc 1 420 47 discriminator 4 view .LVU379
 1399 02d8 712B      		or r23,r17
 1400 02da 822B      		or r24,r18
 1401 02dc 932B      		or r25,r19
 1402 02de C230      		cpi r28,lo8(2)
 1403 02e0 01F0      		breq .L98
 1404 02e2 00F4      		brsh .L99
 1405 02e4 C130      		cpi r28,lo8(1)
 1406 02e6 01F0      		breq .L100
 422:tmk_core/common/action.c ****                             break;
 1407               		.loc 1 422 29 is_stmt 1 view .LVU380
 1408 02e8 0E94 0000 		call default_layer_and
 1409               	.LVL133:
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1410               		.loc 1 423 29 view .LVU381
 1411 02ec 00C0      		rjmp .L49
 1412               	.L100:
 425:tmk_core/common/action.c ****                             break;
 1413               		.loc 1 425 29 view .LVU382
 1414 02ee 0E94 0000 		call default_layer_or
 1415               	.LVL134:
 426:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1416               		.loc 1 426 29 view .LVU383
 1417 02f2 00C0      		rjmp .L49
 1418               	.L98:
 428:tmk_core/common/action.c ****                             break;
 1419               		.loc 1 428 29 view .LVU384
 1420 02f4 0E94 0000 		call default_layer_xor
 1421               	.LVL135:
 429:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1422               		.loc 1 429 29 view .LVU385
 1423 02f8 00C0      		rjmp .L49
 1424               	.L99:
 431:tmk_core/common/action.c ****                             break;
 1425               		.loc 1 431 29 view .LVU386
 1426 02fa 0E94 0000 		call default_layer_set
 1427               	.LVL136:
 432:tmk_core/common/action.c ****                     }
 1428               		.loc 1 432 29 view .LVU387
 1429 02fe 00C0      		rjmp .L49
 1430               	.LVL137:
 1431               	.L96:
 432:tmk_core/common/action.c ****                     }
 1432               		.loc 1 432 29 is_stmt 0 view .LVU388
 1433               	.LBE52:
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1434               		.loc 1 437 17 is_stmt 1 view .LVU389
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1435               		.loc 1 437 21 is_stmt 0 view .LVU390
 1436 0300 8695      		lsr r24
 1437 0302 1123      		tst r17
 1438 0304 01F0      		breq .L102
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1439               		.loc 1 437 21 discriminator 1 view .LVU391
 1440 0306 8C2F      		mov r24,r28
 1441 0308 8170      		andi r24,lo8(1)
 1442               	.L102:
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1443               		.loc 1 437 20 discriminator 4 view .LVU392
 1444 030a 8823      		tst r24
 1445 030c 01F4      		brne .+2
 1446 030e 00C0      		rjmp .L49
 1447               	.LBB53:
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1448               		.loc 1 438 21 is_stmt 1 view .LVU393
 1449               	.LVL138:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1450               		.loc 1 439 21 view .LVU394
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1451               		.loc 1 438 61 is_stmt 0 view .LVU395
 1452 0310 4D2F      		mov r20,r29
 1453 0312 4295      		swap r20
 1454 0314 4695      		lsr r20
 1455 0316 4770      		andi r20,lo8(7)
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1456               		.loc 1 438 35 view .LVU396
 1457 0318 440F      		lsl r20
 1458 031a 440F      		lsl r20
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1459               		.loc 1 439 77 view .LVU397
 1460 031c 0D2F      		mov r16,r29
 1461               	.LVL139:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1462               		.loc 1 439 77 view .LVU398
 1463 031e 0F70      		andi r16,lo8(15)
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1464               		.loc 1 439 44 view .LVU399
 1465 0320 10E0      		ldi r17,0
 1466               	.LVL140:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1467               		.loc 1 439 44 view .LVU400
 1468 0322 30E0      		ldi r19,0
 1469 0324 20E0      		ldi r18,0
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1470               		.loc 1 439 35 view .LVU401
 1471 0326 042E      		mov r0,r20
 1472 0328 00C0      		rjmp 2f
 1473               		1:
 1474 032a 000F      		lsl r16
 1475 032c 111F      		rol r17
 1476 032e 221F      		rol r18
 1477 0330 331F      		rol r19
 1478               		2:
 1479 0332 0A94      		dec r0
 1480 0334 02F4      		brpl 1b
 1481               	.LVL141:
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1482               		.loc 1 440 21 is_stmt 1 view .LVU402
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1483               		.loc 1 440 104 is_stmt 0 view .LVU403
 1484 0336 60E0      		ldi r22,0
 1485 0338 70E0      		ldi r23,0
 1486 033a CB01      		movw r24,r22
 1487 033c D4FF      		sbrs r29,4
 1488 033e 00C0      		rjmp .L103
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1489               		.loc 1 440 94 discriminator 1 view .LVU404
 1490 0340 6FE0      		ldi r22,lo8(15)
 1491 0342 70E0      		ldi r23,0
 1492 0344 80E0      		ldi r24,0
 1493 0346 90E0      		ldi r25,0
 1494 0348 00C0      		rjmp 2f
 1495               		1:
 1496 034a 660F      		lsl r22
 1497 034c 771F      		rol r23
 1498 034e 881F      		rol r24
 1499 0350 991F      		rol r25
 1500               		2:
 1501 0352 4A95      		dec r20
 1502 0354 02F4      		brpl 1b
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1503               		.loc 1 440 104 discriminator 1 view .LVU405
 1504 0356 6095      		com r22
 1505 0358 7095      		com r23
 1506 035a 8095      		com r24
 1507 035c 9095      		com r25
 1508               	.L103:
 1509               	.LVL142:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1510               		.loc 1 441 21 is_stmt 1 discriminator 4 view .LVU406
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1511               		.loc 1 441 47 is_stmt 0 discriminator 4 view .LVU407
 1512 035e C695      		lsr r28
 1513 0360 C695      		lsr r28
 1514               	.LVL143:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1515               		.loc 1 441 47 discriminator 4 view .LVU408
 1516 0362 C370      		andi r28,lo8(3)
 1517 0364 602B      		or r22,r16
 1518               	.LVL144:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1519               		.loc 1 441 47 discriminator 4 view .LVU409
 1520 0366 712B      		or r23,r17
 1521 0368 822B      		or r24,r18
 1522 036a 932B      		or r25,r19
 1523 036c C230      		cpi r28,lo8(2)
 1524 036e 01F0      		breq .L104
 1525 0370 00F4      		brsh .L105
 1526 0372 C130      		cpi r28,lo8(1)
 1527 0374 01F0      		breq .L106
 443:tmk_core/common/action.c ****                             break;
 1528               		.loc 1 443 29 is_stmt 1 view .LVU410
 1529 0376 0E94 0000 		call layer_and
 1530               	.LVL145:
 444:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1531               		.loc 1 444 29 view .LVU411
 1532 037a 00C0      		rjmp .L49
 1533               	.L106:
 446:tmk_core/common/action.c ****                             break;
 1534               		.loc 1 446 29 view .LVU412
 1535 037c 0E94 0000 		call layer_or
 1536               	.LVL146:
 447:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1537               		.loc 1 447 29 view .LVU413
 1538 0380 00C0      		rjmp .L49
 1539               	.L104:
 449:tmk_core/common/action.c ****                             break;
 1540               		.loc 1 449 29 view .LVU414
 1541 0382 0E94 0000 		call layer_xor
 1542               	.LVL147:
 450:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1543               		.loc 1 450 29 view .LVU415
 1544 0386 00C0      		rjmp .L49
 1545               	.L105:
 452:tmk_core/common/action.c ****                             break;
 1546               		.loc 1 452 29 view .LVU416
 1547 0388 0E94 0000 		call layer_state_set
 1548               	.LVL148:
 453:tmk_core/common/action.c ****                     }
 1549               		.loc 1 453 29 view .LVU417
 1550 038c 00C0      		rjmp .L49
 1551               	.LVL149:
 1552               	.L54:
 453:tmk_core/common/action.c ****                     }
 1553               		.loc 1 453 29 is_stmt 0 view .LVU418
 1554               	.LBE53:
 459:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1555               		.loc 1 459 13 is_stmt 1 view .LVU419
 1556 038e CF70      		andi r28,lo8(15)
 1557               	.LVL150:
 459:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1558               		.loc 1 459 16 is_stmt 0 view .LVU420
 1559 0390 1123      		tst r17
 1560 0392 01F0      		breq .L107
 460:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1561               		.loc 1 460 17 is_stmt 1 view .LVU421
 1562 0394 8C2F      		mov r24,r28
 1563 0396 0E94 0000 		call layer_on
 1564               	.LVL151:
 461:tmk_core/common/action.c ****             } else {
 1565               		.loc 1 461 17 view .LVU422
 1566 039a 8D2F      		mov r24,r29
 1567 039c 00C0      		rjmp .L162
 1568               	.L107:
 463:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1569               		.loc 1 463 17 view .LVU423
 1570 039e 8D2F      		mov r24,r29
 1571 03a0 0E94 0000 		call unregister_mods
 1572               	.LVL152:
 464:tmk_core/common/action.c ****             }
 1573               		.loc 1 464 17 view .LVU424
 1574 03a4 8C2F      		mov r24,r28
 1575               	.LVL153:
 1576               	.L161:
 551:tmk_core/common/action.c ****                         }
 1577               		.loc 1 551 29 is_stmt 0 view .LVU425
 1578 03a6 0E94 0000 		call layer_off
 1579               	.LVL154:
 1580 03aa 00C0      		rjmp .L49
 1581               	.L53:
 470:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1582               		.loc 1 470 13 is_stmt 1 view .LVU426
 1583 03ac D23F      		cpi r29,lo8(-14)
 1584 03ae 01F0      		breq .L108
 1585 03b0 00F4      		brsh .L109
 1586 03b2 D03F      		cpi r29,lo8(-16)
 1587 03b4 01F0      		breq .L110
 1588 03b6 D13F      		cpi r29,lo8(-15)
 1589 03b8 01F0      		breq .L111
 1590               	.L112:
 532:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1591               		.loc 1 532 21 view .LVU427
 532:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1592               		.loc 1 532 24 is_stmt 0 view .LVU428
 1593 03ba 1123      		tst r17
 1594 03bc 01F4      		brne .+2
 1595 03be 00C0      		rjmp .L121
 533:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1596               		.loc 1 533 25 is_stmt 1 view .LVU429
 533:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1597               		.loc 1 533 28 is_stmt 0 view .LVU430
 1598 03c0 0111      		cpse r16,__zero_reg__
 1599 03c2 00C0      		rjmp .L163
 537:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1600               		.loc 1 537 76 is_stmt 1 view .LVU431
 538:tmk_core/common/action.c ****                         }
 1601               		.loc 1 538 29 view .LVU432
 1602 03c4 8C2F      		mov r24,r28
 1603 03c6 8F71      		andi r24,lo8(31)
 1604 03c8 00C0      		rjmp .L158
 1605               	.L109:
 1606 03ca D33F      		cpi r29,lo8(-13)
 1607 03cc 01F0      		breq .L113
 1608 03ce D43F      		cpi r29,lo8(-12)
 1609 03d0 01F4      		brne .L112
 518:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1610               		.loc 1 518 21 view .LVU433
 518:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1611               		.loc 1 518 24 is_stmt 0 view .LVU434
 1612 03d2 1123      		tst r17
 1613 03d4 01F0      		breq .L120
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1614               		.loc 1 519 25 is_stmt 1 view .LVU435
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1615               		.loc 1 519 50 is_stmt 0 view .LVU436
 1616 03d6 CF71      		andi r28,lo8(31)
 1617               	.LVL155:
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1618               		.loc 1 519 25 view .LVU437
 1619 03d8 8C2F      		mov r24,r28
 1620 03da 0E94 0000 		call layer_on
 1621               	.LVL156:
 520:tmk_core/common/action.c ****                     } else {
 1622               		.loc 1 520 25 is_stmt 1 view .LVU438
 1623 03de 63E0      		ldi r22,lo8(3)
 1624 03e0 8C2F      		mov r24,r28
 1625 03e2 0E94 0000 		call set_oneshot_layer
 1626               	.LVL157:
 1627 03e6 00C0      		rjmp .L49
 1628               	.LVL158:
 1629               	.L110:
 473:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1630               		.loc 1 473 21 view .LVU439
 473:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1631               		.loc 1 473 24 is_stmt 0 view .LVU440
 1632 03e8 1123      		tst r17
 1633 03ea 01F0      		breq .L115
 474:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1634               		.loc 1 474 25 is_stmt 1 view .LVU441
 474:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1635               		.loc 1 474 28 is_stmt 0 view .LVU442
 1636 03ec 0530      		cpi r16,lo8(5)
 1637 03ee 00F0      		brlo .+2
 1638 03f0 00C0      		rjmp .L49
 1639               	.L116:
 475:tmk_core/common/action.c ****                         }
 1640               		.loc 1 475 29 is_stmt 1 view .LVU443
 1641 03f2 8C2F      		mov r24,r28
 1642 03f4 8F71      		andi r24,lo8(31)
 1643 03f6 0E94 0000 		call layer_invert
 1644               	.LVL159:
 1645 03fa 00C0      		rjmp .L49
 1646               	.L115:
 478:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1647               		.loc 1 478 25 view .LVU444
 478:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1648               		.loc 1 478 28 is_stmt 0 view .LVU445
 1649 03fc 0630      		cpi r16,lo8(6)
 1650 03fe 00F0      		brlo .+2
 1651 0400 00C0      		rjmp .L49
 1652 0402 00C0      		rjmp .L116
 1653               	.L111:
 484:tmk_core/common/action.c ****                     break;
 1654               		.loc 1 484 21 is_stmt 1 view .LVU446
 1655 0404 8C2F      		mov r24,r28
 1656 0406 8F71      		andi r24,lo8(31)
 484:tmk_core/common/action.c ****                     break;
 1657               		.loc 1 484 68 is_stmt 0 view .LVU447
 1658 0408 1123      		tst r17
 1659 040a 01F0      		breq .L161
 1660               	.L158:
 538:tmk_core/common/action.c ****                         }
 1661               		.loc 1 538 29 view .LVU448
 1662 040c 0E94 0000 		call layer_on
 1663               	.LVL160:
 1664 0410 00C0      		rjmp .L49
 1665               	.L108:
 487:tmk_core/common/action.c ****                     break;
 1666               		.loc 1 487 21 is_stmt 1 view .LVU449
 1667 0412 8C2F      		mov r24,r28
 1668 0414 8F71      		andi r24,lo8(31)
 487:tmk_core/common/action.c ****                     break;
 1669               		.loc 1 487 69 is_stmt 0 view .LVU450
 1670 0416 1123      		tst r17
 1671 0418 01F0      		breq .L158
 1672 041a 00C0      		rjmp .L161
 1673               	.L113:
 490:tmk_core/common/action.c ****                     break;
 1674               		.loc 1 490 21 is_stmt 1 view .LVU451
 490:tmk_core/common/action.c ****                     break;
 1675               		.loc 1 490 70 is_stmt 0 view .LVU452
 1676 041c 1123      		tst r17
 1677 041e 01F0      		breq .L119
 490:tmk_core/common/action.c ****                     break;
 1678               		.loc 1 490 37 discriminator 1 view .LVU453
 1679 0420 8C2F      		mov r24,r28
 1680 0422 8F71      		andi r24,lo8(31)
 1681 0424 0E94 0000 		call layer_move
 1682               	.LVL161:
 1683 0428 00C0      		rjmp .L49
 1684               	.L119:
 490:tmk_core/common/action.c ****                     break;
 1685               		.loc 1 490 72 discriminator 2 view .LVU454
 1686 042a 0E94 0000 		call layer_clear
 1687               	.LVL162:
 1688 042e 00C0      		rjmp .L49
 1689               	.L120:
 522:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1690               		.loc 1 522 25 is_stmt 1 view .LVU455
 1691 0430 81E0      		ldi r24,lo8(1)
 1692 0432 0E94 0000 		call clear_oneshot_layer_state
 1693               	.LVL163:
 523:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1694               		.loc 1 523 25 view .LVU456
 523:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1695               		.loc 1 523 28 is_stmt 0 view .LVU457
 1696 0436 0230      		cpi r16,lo8(2)
 1697 0438 00F4      		brsh .+2
 1698 043a 00C0      		rjmp .L49
 524:tmk_core/common/action.c ****                         }
 1699               		.loc 1 524 29 is_stmt 1 view .LVU458
 1700 043c 82E0      		ldi r24,lo8(2)
 1701 043e 0E94 0000 		call clear_oneshot_layer_state
 1702               	.LVL164:
 1703 0442 00C0      		rjmp .L49
 1704               	.L121:
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1705               		.loc 1 541 25 view .LVU459
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1706               		.loc 1 541 28 is_stmt 0 view .LVU460
 1707 0444 0023      		tst r16
 1708 0446 01F0      		breq .L123
 542:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1709               		.loc 1 542 77 is_stmt 1 view .LVU461
 543:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1710               		.loc 1 543 29 view .LVU462
 543:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1711               		.loc 1 543 32 is_stmt 0 view .LVU463
 1712 0448 D933      		cpi r29,lo8(57)
 1713 044a 01F0      		breq .+2
 1714 044c 00C0      		rjmp .L125
 544:tmk_core/common/action.c ****                             } else {
 1715               		.loc 1 544 33 is_stmt 1 view .LVU464
 1716               	.LVL165:
 1717               	.LBB54:
 1718               	.LBI49:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1719               		.loc 2 166 1 view .LVU465
 1720               	.LBB51:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1721               		.loc 2 168 2 view .LVU466
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1722               		.loc 2 172 2 view .LVU467
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1723               		.loc 2 173 2 view .LVU468
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1724               		.loc 2 174 2 view .LVU469
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1725               		.loc 2 184 3 view .LVU470
 1726               		.loc 2 187 2 view .LVU471
 1727 044e 8FEF      		ldi r24,lo8(255999)
 1728 0450 97EE      		ldi r25,hi8(255999)
 1729 0452 E3E0      		ldi r30,hlo8(255999)
 1730 0454 8150      	1:	subi r24,1
 1731 0456 9040      		sbci r25,0
 1732 0458 E040      		sbci r30,0
 1733 045a 01F4      		brne 1b
 1734 045c 00C0      		rjmp .L166
 1735               	.LVL166:
 1736               	.L123:
 1737               		.loc 2 187 2 is_stmt 0 view .LVU472
 1738               	.LBE51:
 1739               	.LBE54:
 550:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1740               		.loc 1 550 79 is_stmt 1 view .LVU473
 551:tmk_core/common/action.c ****                         }
 1741               		.loc 1 551 29 view .LVU474
 1742 045e 8C2F      		mov r24,r28
 1743 0460 8F71      		andi r24,lo8(31)
 1744 0462 00C0      		rjmp .L161
 1745               	.L52:
 562:tmk_core/common/action.c ****             break;
 1746               		.loc 1 562 13 view .LVU475
 562:tmk_core/common/action.c ****             break;
 1747               		.loc 1 562 83 is_stmt 0 view .LVU476
 1748 0464 4C2F      		mov r20,r28
 1749 0466 4F70      		andi r20,lo8(15)
 562:tmk_core/common/action.c ****             break;
 1750               		.loc 1 562 13 view .LVU477
 1751 0468 6D2F      		mov r22,r29
 1752 046a C601      		movw r24,r12
 1753 046c 0E94 0000 		call action_get_macro
 1754               	.LVL167:
 1755 0470 0E94 0000 		call action_macro_play
 1756               	.LVL168:
 563:tmk_core/common/action.c **** #endif
 1757               		.loc 1 563 13 is_stmt 1 view .LVU478
 1758 0474 00C0      		rjmp .L49
 1759               	.L50:
 658:tmk_core/common/action.c ****             break;
 1760               		.loc 1 658 13 view .LVU479
 658:tmk_core/common/action.c ****             break;
 1761               		.loc 1 658 64 is_stmt 0 view .LVU480
 1762 0476 4C2F      		mov r20,r28
 1763 0478 4F70      		andi r20,lo8(15)
 658:tmk_core/common/action.c ****             break;
 1764               		.loc 1 658 13 view .LVU481
 1765 047a 6D2F      		mov r22,r29
 1766 047c C601      		movw r24,r12
 1767 047e 0E94 0000 		call action_function
 1768               	.LVL169:
 659:tmk_core/common/action.c **** #endif
 1769               		.loc 1 659 13 is_stmt 1 view .LVU482
 1770 0482 00C0      		rjmp .L49
 1771               	.LVL170:
 1772               	.L46:
 1773               	/* epilogue start */
 716:tmk_core/common/action.c **** 
 1774               		.loc 1 716 1 is_stmt 0 view .LVU483
 1775 0484 DF91      		pop r29
 1776               	.LVL171:
 716:tmk_core/common/action.c **** 
 1777               		.loc 1 716 1 view .LVU484
 1778 0486 CF91      		pop r28
 716:tmk_core/common/action.c **** 
 1779               		.loc 1 716 1 view .LVU485
 1780 0488 1F91      		pop r17
 1781 048a 0F91      		pop r16
 1782 048c FF90      		pop r15
 1783 048e EF90      		pop r14
 1784               	.LVL172:
 716:tmk_core/common/action.c **** 
 1785               		.loc 1 716 1 view .LVU486
 1786 0490 DF90      		pop r13
 1787 0492 CF90      		pop r12
 1788               	.LVL173:
 716:tmk_core/common/action.c **** 
 1789               		.loc 1 716 1 view .LVU487
 1790 0494 BF90      		pop r11
 1791 0496 0895      		ret
 1792               		.cfi_endproc
 1793               	.LFE108:
 1795               		.section	.text.process_record,"ax",@progbits
 1796               	.global	process_record
 1798               	process_record:
 1799               	.LVL174:
 1800               	.LFB107:
 181:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1801               		.loc 1 181 42 is_stmt 1 view -0
 1802               		.cfi_startproc
 181:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1803               		.loc 1 181 42 is_stmt 0 view .LVU489
 1804 0000 0F93      		push r16
 1805               	.LCFI14:
 1806               		.cfi_def_cfa_offset 3
 1807               		.cfi_offset 16, -2
 1808 0002 1F93      		push r17
 1809               	.LCFI15:
 1810               		.cfi_def_cfa_offset 4
 1811               		.cfi_offset 17, -3
 1812 0004 CF93      		push r28
 1813               	.LCFI16:
 1814               		.cfi_def_cfa_offset 5
 1815               		.cfi_offset 28, -4
 1816 0006 DF93      		push r29
 1817               	.LCFI17:
 1818               		.cfi_def_cfa_offset 6
 1819               		.cfi_offset 29, -5
 1820               	/* prologue: function */
 1821               	/* frame size = 0 */
 1822               	/* stack size = 4 */
 1823               	.L__stack_usage = 4
 1824 0008 EC01      		movw r28,r24
 182:tmk_core/common/action.c ****         return;
 1825               		.loc 1 182 5 is_stmt 1 view .LVU490
 1826               	.LBB57:
 1827               	.LBI57:
 1828               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1829               		.loc 4 48 20 view .LVU491
 1830               	.LBB58:
 1831               		.loc 4 48 51 view .LVU492
 1832               		.loc 4 48 74 is_stmt 0 view .LVU493
 1833 000a 8B81      		ldd r24,Y+3
 1834 000c 9C81      		ldd r25,Y+4
 1835               	.LVL175:
 1836               		.loc 4 48 74 view .LVU494
 1837 000e 892B      		or r24,r25
 1838 0010 01F0      		breq .L167
 1839 0012 8881      		ld r24,Y
 1840 0014 9981      		ldd r25,Y+1
 1841 0016 8923      		and r24,r25
 1842 0018 8F3F      		cpi r24,lo8(-1)
 1843 001a 01F4      		brne .L177
 1844               	.L167:
 1845               	/* epilogue start */
 1846               	.LBE58:
 1847               	.LBE57:
 200:tmk_core/common/action.c **** 
 1848               		.loc 1 200 1 view .LVU495
 1849 001c DF91      		pop r29
 1850 001e CF91      		pop r28
 1851               	.LVL176:
 200:tmk_core/common/action.c **** 
 1852               		.loc 1 200 1 view .LVU496
 1853 0020 1F91      		pop r17
 1854 0022 0F91      		pop r16
 1855 0024 0895      		ret
 1856               	.LVL177:
 1857               	.L177:
 186:tmk_core/common/action.c **** 
 1858               		.loc 1 186 5 is_stmt 1 view .LVU497
 186:tmk_core/common/action.c **** 
 1859               		.loc 1 186 10 is_stmt 0 view .LVU498
 1860 0026 CE01      		movw r24,r28
 1861 0028 0E94 0000 		call process_record_quantum
 1862               	.LVL178:
 186:tmk_core/common/action.c **** 
 1863               		.loc 1 186 8 view .LVU499
 1864 002c 8823      		tst r24
 1865 002e 01F0      		breq .L167
 188:tmk_core/common/action.c ****     dprint("ACTION: ");
 1866               		.loc 1 188 5 is_stmt 1 view .LVU500
 188:tmk_core/common/action.c ****     dprint("ACTION: ");
 1867               		.loc 1 188 23 is_stmt 0 view .LVU501
 1868 0030 6881      		ld r22,Y
 1869 0032 7981      		ldd r23,Y+1
 1870 0034 8A81      		ldd r24,Y+2
 1871 0036 0E94 0000 		call store_or_get_action
 1872               	.LVL179:
 1873 003a 8C01      		movw r16,r24
 1874               	.LVL180:
 189:tmk_core/common/action.c ****     debug_action(action);
 1875               		.loc 1 189 23 is_stmt 1 view .LVU502
 190:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1876               		.loc 1 190 5 view .LVU503
 192:tmk_core/common/action.c ****     layer_debug();
 1877               		.loc 1 192 29 view .LVU504
 193:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1878               		.loc 1 193 5 view .LVU505
 1879 003c 0E94 0000 		call layer_debug
 1880               	.LVL181:
 194:tmk_core/common/action.c ****     default_layer_debug();
 1881               		.loc 1 194 37 view .LVU506
 195:tmk_core/common/action.c **** #endif
 1882               		.loc 1 195 5 view .LVU507
 1883 0040 0E94 0000 		call default_layer_debug
 1884               	.LVL182:
 197:tmk_core/common/action.c **** 
 1885               		.loc 1 197 15 view .LVU508
 199:tmk_core/common/action.c **** }
 1886               		.loc 1 199 5 view .LVU509
 199:tmk_core/common/action.c **** }
 1887               		.loc 1 199 5 is_stmt 0 view .LVU510
 1888 0044 B801      		movw r22,r16
 1889 0046 CE01      		movw r24,r28
 1890               	/* epilogue start */
 200:tmk_core/common/action.c **** 
 1891               		.loc 1 200 1 view .LVU511
 1892 0048 DF91      		pop r29
 1893 004a CF91      		pop r28
 1894               	.LVL183:
 200:tmk_core/common/action.c **** 
 1895               		.loc 1 200 1 view .LVU512
 1896 004c 1F91      		pop r17
 1897 004e 0F91      		pop r16
 1898               	.LVL184:
 199:tmk_core/common/action.c **** }
 1899               		.loc 1 199 5 view .LVU513
 1900 0050 0C94 0000 		jmp process_action
 1901               	.LVL185:
 199:tmk_core/common/action.c **** }
 1902               		.loc 1 199 5 view .LVU514
 1903               		.cfi_endproc
 1904               	.LFE107:
 1906               		.section	.text.process_record_nocache,"ax",@progbits
 1907               	.global	process_record_nocache
 1909               	process_record_nocache:
 1910               	.LVL186:
 1911               	.LFB104:
 143:tmk_core/common/action.c ****     disable_action_cache = true;
 1912               		.loc 1 143 50 is_stmt 1 view -0
 1913               		.cfi_startproc
 1914               	/* prologue: function */
 1915               	/* frame size = 0 */
 1916               	/* stack size = 0 */
 1917               	.L__stack_usage = 0
 144:tmk_core/common/action.c ****     process_record(record);
 1918               		.loc 1 144 5 view .LVU516
 144:tmk_core/common/action.c ****     process_record(record);
 1919               		.loc 1 144 26 is_stmt 0 view .LVU517
 1920 0000 21E0      		ldi r18,lo8(1)
 1921 0002 2093 0000 		sts disable_action_cache,r18
 145:tmk_core/common/action.c ****     disable_action_cache = false;
 1922               		.loc 1 145 5 is_stmt 1 view .LVU518
 1923 0006 0E94 0000 		call process_record
 1924               	.LVL187:
 146:tmk_core/common/action.c **** }
 1925               		.loc 1 146 5 view .LVU519
 146:tmk_core/common/action.c **** }
 1926               		.loc 1 146 26 is_stmt 0 view .LVU520
 1927 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1928               	/* epilogue start */
 147:tmk_core/common/action.c **** #else
 1929               		.loc 1 147 1 view .LVU521
 1930 000e 0895      		ret
 1931               		.cfi_endproc
 1932               	.LFE104:
 1934               		.section	.text.register_weak_mods,"ax",@progbits
 1935               	.global	register_weak_mods
 1937               	register_weak_mods:
 1938               	.LVL188:
 1939               	.LFB114:
 905:tmk_core/common/action.c **** 
 906:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 907:tmk_core/common/action.c ****  *
 908:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 909:tmk_core/common/action.c ****  */
 910:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1940               		.loc 1 910 39 is_stmt 1 view -0
 1941               		.cfi_startproc
 1942               	/* prologue: function */
 1943               	/* frame size = 0 */
 1944               	/* stack size = 0 */
 1945               	.L__stack_usage = 0
 911:tmk_core/common/action.c ****     if (mods) {
 1946               		.loc 1 911 5 view .LVU523
 1947               		.loc 1 911 8 is_stmt 0 view .LVU524
 1948 0000 8823      		tst r24
 1949 0002 01F0      		breq .L179
 912:tmk_core/common/action.c ****         add_weak_mods(mods);
 1950               		.loc 1 912 9 is_stmt 1 view .LVU525
 1951 0004 0E94 0000 		call add_weak_mods
 1952               	.LVL189:
 913:tmk_core/common/action.c ****         send_keyboard_report();
 1953               		.loc 1 913 9 view .LVU526
 1954 0008 0C94 0000 		jmp send_keyboard_report
 1955               	.LVL190:
 1956               	.L179:
 1957               	/* epilogue start */
 914:tmk_core/common/action.c ****     }
 915:tmk_core/common/action.c **** }
 1958               		.loc 1 915 1 is_stmt 0 view .LVU527
 1959 000c 0895      		ret
 1960               		.cfi_endproc
 1961               	.LFE114:
 1963               		.section	.text.unregister_weak_mods,"ax",@progbits
 1964               	.global	unregister_weak_mods
 1966               	unregister_weak_mods:
 1967               	.LVL191:
 1968               	.LFB115:
 916:tmk_core/common/action.c **** 
 917:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 918:tmk_core/common/action.c ****  *
 919:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 920:tmk_core/common/action.c ****  */
 921:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1969               		.loc 1 921 41 is_stmt 1 view -0
 1970               		.cfi_startproc
 1971               	/* prologue: function */
 1972               	/* frame size = 0 */
 1973               	/* stack size = 0 */
 1974               	.L__stack_usage = 0
 922:tmk_core/common/action.c ****     if (mods) {
 1975               		.loc 1 922 5 view .LVU529
 1976               		.loc 1 922 8 is_stmt 0 view .LVU530
 1977 0000 8823      		tst r24
 1978 0002 01F0      		breq .L181
 923:tmk_core/common/action.c ****         del_weak_mods(mods);
 1979               		.loc 1 923 9 is_stmt 1 view .LVU531
 1980 0004 0E94 0000 		call del_weak_mods
 1981               	.LVL192:
 924:tmk_core/common/action.c ****         send_keyboard_report();
 1982               		.loc 1 924 9 view .LVU532
 1983 0008 0C94 0000 		jmp send_keyboard_report
 1984               	.LVL193:
 1985               	.L181:
 1986               	/* epilogue start */
 925:tmk_core/common/action.c ****     }
 926:tmk_core/common/action.c **** }
 1987               		.loc 1 926 1 is_stmt 0 view .LVU533
 1988 000c 0895      		ret
 1989               		.cfi_endproc
 1990               	.LFE115:
 1992               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1993               	.global	clear_keyboard_but_mods_and_keys
 1995               	clear_keyboard_but_mods_and_keys:
 1996               	.LFB118:
 927:tmk_core/common/action.c **** 
 928:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 929:tmk_core/common/action.c ****  *
 930:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 931:tmk_core/common/action.c ****  */
 932:tmk_core/common/action.c **** void clear_keyboard(void) {
 933:tmk_core/common/action.c ****     clear_mods();
 934:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 935:tmk_core/common/action.c **** }
 936:tmk_core/common/action.c **** 
 937:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 938:tmk_core/common/action.c ****  *
 939:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 940:tmk_core/common/action.c ****  */
 941:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 942:tmk_core/common/action.c ****     clear_keys();
 943:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 944:tmk_core/common/action.c **** }
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1997               		.loc 1 950 41 is_stmt 1 view -0
 1998               		.cfi_startproc
 1999               	/* prologue: function */
 2000               	/* frame size = 0 */
 2001               	/* stack size = 0 */
 2002               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     clear_weak_mods();
 2003               		.loc 1 951 5 view .LVU535
 2004 0000 0E94 0000 		call clear_weak_mods
 2005               	.LVL194:
 952:tmk_core/common/action.c ****     clear_macro_mods();
 2006               		.loc 1 952 5 view .LVU536
 2007 0004 0E94 0000 		call clear_macro_mods
 2008               	.LVL195:
 953:tmk_core/common/action.c ****     send_keyboard_report();
 2009               		.loc 1 953 5 view .LVU537
 2010 0008 0E94 0000 		call send_keyboard_report
 2011               	.LVL196:
 954:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 955:tmk_core/common/action.c ****     mousekey_clear();
 2012               		.loc 1 955 5 view .LVU538
 2013 000c 0E94 0000 		call mousekey_clear
 2014               	.LVL197:
 956:tmk_core/common/action.c ****     mousekey_send();
 2015               		.loc 1 956 5 view .LVU539
 2016 0010 0E94 0000 		call mousekey_send
 2017               	.LVL198:
 957:tmk_core/common/action.c **** #endif
 958:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 959:tmk_core/common/action.c ****     host_system_send(0);
 2018               		.loc 1 959 5 view .LVU540
 2019 0014 90E0      		ldi r25,0
 2020 0016 80E0      		ldi r24,0
 2021 0018 0E94 0000 		call host_system_send
 2022               	.LVL199:
 960:tmk_core/common/action.c ****     host_consumer_send(0);
 2023               		.loc 1 960 5 view .LVU541
 2024 001c 90E0      		ldi r25,0
 2025 001e 80E0      		ldi r24,0
 2026 0020 0C94 0000 		jmp host_consumer_send
 2027               	.LVL200:
 2028               		.cfi_endproc
 2029               	.LFE118:
 2031               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2032               	.global	clear_keyboard_but_mods
 2034               	clear_keyboard_but_mods:
 2035               	.LFB117:
 941:tmk_core/common/action.c ****     clear_keys();
 2036               		.loc 1 941 36 view -0
 2037               		.cfi_startproc
 2038               	/* prologue: function */
 2039               	/* frame size = 0 */
 2040               	/* stack size = 0 */
 2041               	.L__stack_usage = 0
 942:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2042               		.loc 1 942 5 view .LVU543
 2043 0000 0E94 0000 		call clear_keys
 2044               	.LVL201:
 943:tmk_core/common/action.c **** }
 2045               		.loc 1 943 5 view .LVU544
 2046 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2047               	.LVL202:
 2048               		.cfi_endproc
 2049               	.LFE117:
 2051               		.section	.text.clear_keyboard,"ax",@progbits
 2052               	.global	clear_keyboard
 2054               	clear_keyboard:
 2055               	.LFB116:
 932:tmk_core/common/action.c ****     clear_mods();
 2056               		.loc 1 932 27 view -0
 2057               		.cfi_startproc
 2058               	/* prologue: function */
 2059               	/* frame size = 0 */
 2060               	/* stack size = 0 */
 2061               	.L__stack_usage = 0
 933:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2062               		.loc 1 933 5 view .LVU546
 2063 0000 0E94 0000 		call clear_mods
 2064               	.LVL203:
 934:tmk_core/common/action.c **** }
 2065               		.loc 1 934 5 view .LVU547
 2066 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2067               	.LVL204:
 2068               		.cfi_endproc
 2069               	.LFE116:
 2071               		.section	.text.is_tap_action,"ax",@progbits
 2072               	.global	is_tap_action
 2074               	is_tap_action:
 2075               	.LVL205:
 2076               	.LFB120:
 961:tmk_core/common/action.c **** #endif
 962:tmk_core/common/action.c **** }
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 969:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 970:tmk_core/common/action.c ****     return is_tap_action(action);
 971:tmk_core/common/action.c **** }
 972:tmk_core/common/action.c **** 
 973:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 974:tmk_core/common/action.c ****  *
 975:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 976:tmk_core/common/action.c ****  */
 977:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2077               		.loc 1 977 37 view -0
 2078               		.cfi_startproc
 2079               	/* prologue: function */
 2080               	/* frame size = 0 */
 2081               	/* stack size = 0 */
 2082               	.L__stack_usage = 0
 978:tmk_core/common/action.c ****     switch (action.kind.id) {
 2083               		.loc 1 978 5 view .LVU549
 2084               		.loc 1 978 24 is_stmt 0 view .LVU550
 2085 0000 E92F      		mov r30,r25
 2086 0002 E295      		swap r30
 2087 0004 EF70      		andi r30,lo8(15)
 2088               		.loc 1 978 5 view .LVU551
 2089 0006 E250      		subi r30,lo8(-(-2))
 2090 0008 EE30      		cpi r30,lo8(14)
 2091 000a 00F4      		brsh .L195
 2092 000c F0E0      		ldi r31,0
 2093 000e E050      		subi r30,lo8(-(gs(.L189)))
 2094 0010 F040      		sbci r31,hi8(-(gs(.L189)))
 2095 0012 0C94 0000 		jmp __tablejump2__
 2096               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2097               		.p2align	1
 2098               	.L189:
 2099 0000 0000      		.word gs(.L190)
 2100 0002 0000      		.word gs(.L190)
 2101 0004 0000      		.word gs(.L195)
 2102 0006 0000      		.word gs(.L195)
 2103 0008 0000      		.word gs(.L191)
 2104 000a 0000      		.word gs(.L195)
 2105 000c 0000      		.word gs(.L195)
 2106 000e 0000      		.word gs(.L195)
 2107 0010 0000      		.word gs(.L190)
 2108 0012 0000      		.word gs(.L190)
 2109 0014 0000      		.word gs(.L188)
 2110 0016 0000      		.word gs(.L195)
 2111 0018 0000      		.word gs(.L195)
 2112 001a 0000      		.word gs(.L188)
 2113               		.section	.text.is_tap_action
 2114               	.L190:
 979:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 980:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 981:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 982:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 983:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2115               		.loc 1 983 13 is_stmt 1 view .LVU552
 2116 0016 803F      		cpi r24,lo8(-16)
 2117 0018 01F0      		breq .L198
 2118 001a 00F4      		brsh .L192
 2119 001c 883E      		cpi r24,lo8(-24)
 2120 001e 00F4      		brsh .L195
 2121               	.L198:
 984:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 985:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 986:tmk_core/common/action.c ****                 case OP_ONESHOT:
 987:tmk_core/common/action.c ****                     return true;
 2122               		.loc 1 987 28 is_stmt 0 view .LVU553
 2123 0020 81E0      		ldi r24,lo8(1)
 2124               	.LVL206:
 2125               	/* epilogue start */
 988:tmk_core/common/action.c ****             }
 989:tmk_core/common/action.c ****             return false;
 990:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 991:tmk_core/common/action.c ****             switch (action.swap.code) {
 992:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 993:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 994:tmk_core/common/action.c ****                     return true;
 995:tmk_core/common/action.c ****             }
 996:tmk_core/common/action.c ****             return false;
 997:tmk_core/common/action.c ****         case ACT_MACRO:
 998:tmk_core/common/action.c ****         case ACT_FUNCTION:
 999:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1000:tmk_core/common/action.c ****                 return true;
1001:tmk_core/common/action.c ****             }
1002:tmk_core/common/action.c ****             return false;
1003:tmk_core/common/action.c ****     }
1004:tmk_core/common/action.c ****     return false;
1005:tmk_core/common/action.c **** }
 2126               		.loc 1 1005 1 view .LVU554
 2127 0022 0895      		ret
 2128               	.LVL207:
 2129               	.L192:
 2130               		.loc 1 1005 1 view .LVU555
 2131 0024 843F      		cpi r24,lo8(-12)
 2132 0026 01F0      		breq .L198
 2133               	.L195:
 989:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2134               		.loc 1 989 20 view .LVU556
 2135 0028 80E0      		ldi r24,0
 2136               	.LVL208:
 989:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2137               		.loc 1 989 20 view .LVU557
 2138 002a 0895      		ret
 2139               	.LVL209:
 2140               	.L191:
 991:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2141               		.loc 1 991 13 is_stmt 1 view .LVU558
 2142 002c 883E      		cpi r24,lo8(-24)
 2143 002e 00F0      		brlo .L198
 2144 0030 813F      		cpi r24,lo8(-15)
 2145 0032 01F4      		brne .L195
 2146 0034 00C0      		rjmp .L198
 2147               	.L188:
 999:tmk_core/common/action.c ****                 return true;
 2148               		.loc 1 999 13 view .LVU559
 999:tmk_core/common/action.c ****                 return true;
 2149               		.loc 1 999 16 is_stmt 0 view .LVU560
 2150 0036 93FB      		bst r25,3
 2151 0038 8827      		clr r24
 2152 003a 80F9      		bld r24,0
 2153               	.LVL210:
 999:tmk_core/common/action.c ****                 return true;
 2154               		.loc 1 999 16 view .LVU561
 2155 003c 0895      		ret
 2156               		.cfi_endproc
 2157               	.LFE120:
 2159               		.section	.text.is_tap_key,"ax",@progbits
 2160               	.global	is_tap_key
 2162               	is_tap_key:
 2163               	.LVL211:
 2164               	.LFB119:
 968:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2165               		.loc 1 968 31 is_stmt 1 view -0
 2166               		.cfi_startproc
 2167               	/* prologue: function */
 2168               	/* frame size = 0 */
 2169               	/* stack size = 0 */
 2170               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     return is_tap_action(action);
 2171               		.loc 1 969 5 view .LVU563
 969:tmk_core/common/action.c ****     return is_tap_action(action);
 2172               		.loc 1 969 23 is_stmt 0 view .LVU564
 2173 0000 0E94 0000 		call layer_switch_get_action
 2174               	.LVL212:
 970:tmk_core/common/action.c **** }
 2175               		.loc 1 970 5 is_stmt 1 view .LVU565
 970:tmk_core/common/action.c **** }
 2176               		.loc 1 970 12 is_stmt 0 view .LVU566
 2177 0004 0C94 0000 		jmp is_tap_action
 2178               	.LVL213:
 2179               		.cfi_endproc
 2180               	.LFE119:
 2182               		.section	.text.debug_event,"ax",@progbits
 2183               	.global	debug_event
 2185               	debug_event:
 2186               	.LFB121:
1006:tmk_core/common/action.c **** 
1007:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1008:tmk_core/common/action.c ****  *
1009:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1010:tmk_core/common/action.c ****  */
1011:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2187               		.loc 1 1011 36 is_stmt 1 view -0
 2188               		.cfi_startproc
 2189 0000 CF93      		push r28
 2190               	.LCFI18:
 2191               		.cfi_def_cfa_offset 3
 2192               		.cfi_offset 28, -2
 2193 0002 DF93      		push r29
 2194               	.LCFI19:
 2195               		.cfi_def_cfa_offset 4
 2196               		.cfi_offset 29, -3
 2197 0004 00D0      		rcall .
 2198 0006 00D0      		rcall .
 2199 0008 0F92      		push __tmp_reg__
 2200               	.LCFI20:
 2201               		.cfi_def_cfa_offset 9
 2202 000a CDB7      		in r28,__SP_L__
 2203 000c DEB7      		in r29,__SP_H__
 2204               	.LCFI21:
 2205               		.cfi_def_cfa_register 28
 2206               	/* prologue: function */
 2207               	/* frame size = 5 */
 2208               	/* stack size = 7 */
 2209               	.L__stack_usage = 7
 2210               		.loc 1 1011 138 view .LVU568
 2211               	/* epilogue start */
 2212               		.loc 1 1011 1 is_stmt 0 view .LVU569
 2213 000e 0F90      		pop __tmp_reg__
 2214 0010 0F90      		pop __tmp_reg__
 2215 0012 0F90      		pop __tmp_reg__
 2216 0014 0F90      		pop __tmp_reg__
 2217 0016 0F90      		pop __tmp_reg__
 2218 0018 DF91      		pop r29
 2219 001a CF91      		pop r28
 2220 001c 0895      		ret
 2221               		.cfi_endproc
 2222               	.LFE121:
 2224               		.section	.text.debug_record,"ax",@progbits
 2225               	.global	debug_record
 2227               	debug_record:
 2228               	.LFB122:
1012:tmk_core/common/action.c **** 
1013:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1014:tmk_core/common/action.c ****  *
1015:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1016:tmk_core/common/action.c ****  */
1017:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2229               		.loc 1 1017 39 is_stmt 1 view -0
 2230               		.cfi_startproc
 2231 0000 CF93      		push r28
 2232               	.LCFI22:
 2233               		.cfi_def_cfa_offset 3
 2234               		.cfi_offset 28, -2
 2235 0002 DF93      		push r29
 2236               	.LCFI23:
 2237               		.cfi_def_cfa_offset 4
 2238               		.cfi_offset 29, -3
 2239 0004 00D0      		rcall .
 2240 0006 00D0      		rcall .
 2241 0008 00D0      		rcall .
 2242               	.LCFI24:
 2243               		.cfi_def_cfa_offset 10
 2244 000a CDB7      		in r28,__SP_L__
 2245 000c DEB7      		in r29,__SP_H__
 2246               	.LCFI25:
 2247               		.cfi_def_cfa_register 28
 2248               	/* prologue: function */
 2249               	/* frame size = 6 */
 2250               	/* stack size = 8 */
 2251               	.L__stack_usage = 8
1018:tmk_core/common/action.c ****     debug_event(record.event);
 2252               		.loc 1 1018 5 view .LVU571
1019:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1020:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2253               		.loc 1 1020 77 view .LVU572
 2254               	/* epilogue start */
1021:tmk_core/common/action.c **** #endif
1022:tmk_core/common/action.c **** }
 2255               		.loc 1 1022 1 is_stmt 0 view .LVU573
 2256 000e 2696      		adiw r28,6
 2257 0010 0FB6      		in __tmp_reg__,__SREG__
 2258 0012 F894      		cli
 2259 0014 DEBF      		out __SP_H__,r29
 2260 0016 0FBE      		out __SREG__,__tmp_reg__
 2261 0018 CDBF      		out __SP_L__,r28
 2262 001a DF91      		pop r29
 2263 001c CF91      		pop r28
 2264 001e 0895      		ret
 2265               		.cfi_endproc
 2266               	.LFE122:
 2268               		.section	.text.debug_action,"ax",@progbits
 2269               	.global	debug_action
 2271               	debug_action:
 2272               	.LVL214:
 2273               	.LFB123:
1023:tmk_core/common/action.c **** 
1024:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1025:tmk_core/common/action.c ****  *
1026:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1027:tmk_core/common/action.c ****  */
1028:tmk_core/common/action.c **** void debug_action(action_t action) {
 2274               		.loc 1 1028 36 is_stmt 1 view -0
 2275               		.cfi_startproc
 2276               	/* prologue: function */
 2277               	/* frame size = 0 */
 2278               	/* stack size = 0 */
 2279               	.L__stack_usage = 0
1029:tmk_core/common/action.c ****     switch (action.kind.id) {
 2280               		.loc 1 1029 5 view .LVU575
1030:tmk_core/common/action.c ****         case ACT_LMODS:
1031:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1032:tmk_core/common/action.c ****             break;
1033:tmk_core/common/action.c ****         case ACT_RMODS:
1034:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1035:tmk_core/common/action.c ****             break;
1036:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1037:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1038:tmk_core/common/action.c ****             break;
1039:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1040:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1041:tmk_core/common/action.c ****             break;
1042:tmk_core/common/action.c ****         case ACT_USAGE:
1043:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1044:tmk_core/common/action.c ****             break;
1045:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1046:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1047:tmk_core/common/action.c ****             break;
1048:tmk_core/common/action.c ****         case ACT_LAYER:
1049:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1050:tmk_core/common/action.c ****             break;
1051:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1052:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1053:tmk_core/common/action.c ****             break;
1054:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1055:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1056:tmk_core/common/action.c ****             break;
1057:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1058:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1059:tmk_core/common/action.c ****             break;
1060:tmk_core/common/action.c ****         case ACT_MACRO:
1061:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1062:tmk_core/common/action.c ****             break;
1063:tmk_core/common/action.c ****         case ACT_COMMAND:
1064:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1065:tmk_core/common/action.c ****             break;
1066:tmk_core/common/action.c ****         case ACT_FUNCTION:
1067:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1068:tmk_core/common/action.c ****             break;
1069:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1070:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1071:tmk_core/common/action.c ****             break;
1072:tmk_core/common/action.c ****         default:
1073:tmk_core/common/action.c ****             dprint("UNKNOWN");
1074:tmk_core/common/action.c ****             break;
1075:tmk_core/common/action.c ****     }
1076:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2281               		.loc 1 1076 75 view .LVU576
 2282               	/* epilogue start */
1077:tmk_core/common/action.c **** }
 2283               		.loc 1 1077 1 is_stmt 0 view .LVU577
 2284 0000 0895      		ret
 2285               		.cfi_endproc
 2286               	.LFE123:
 2288               		.section	.rodata.CSWTCH.16,"a"
 2291               	CSWTCH.16:
 2292 0000 E200      		.word	226
 2293 0002 E900      		.word	233
 2294 0004 EA00      		.word	234
 2295 0006 B500      		.word	181
 2296 0008 B600      		.word	182
 2297 000a B700      		.word	183
 2298 000c CD00      		.word	205
 2299 000e 8301      		.word	387
 2300 0010 CC00      		.word	204
 2301 0012 8A01      		.word	394
 2302 0014 9201      		.word	402
 2303 0016 9401      		.word	404
 2304 0018 2102      		.word	545
 2305 001a 2302      		.word	547
 2306 001c 2402      		.word	548
 2307 001e 2502      		.word	549
 2308 0020 2602      		.word	550
 2309 0022 2702      		.word	551
 2310 0024 2A02      		.word	554
 2311 0026 B300      		.word	179
 2312 0028 B400      		.word	180
 2313 002a 6F00      		.word	111
 2314 002c 7000      		.word	112
 2315               		.section	.rodata.CSWTCH.15,"a"
 2318               	CSWTCH.15:
 2319 0000 81        		.byte	-127
 2320 0001 82        		.byte	-126
 2321 0002 83        		.byte	-125
 2322               	.global	disable_action_cache
 2323               		.section	.bss.disable_action_cache,"aw",@nobits
 2326               	disable_action_cache:
 2327 0000 00        		.zero	1
 2328               		.comm	tp_buttons,2,1
 2329               		.text
 2330               	.Letext0:
 2331               		.file 5 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchain
 2332               		.file 6 "tmk_core/common/keycode.h"
 2333               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2334               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2335               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2336               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2337               		.file 11 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchai
 2338               		.file 12 "tmk_core/common/host.h"
 2339               		.file 13 "tmk_core/common/mousekey.h"
 2340               		.file 14 "tmk_core/common/command.h"
 2341               		.file 15 "tmk_core/common/action_code.h"
 2342               		.file 16 "tmk_core/common/action.h"
 2343               		.file 17 "tmk_core/common/action_layer.h"
 2344               		.file 18 "tmk_core/common/action_util.h"
 2345               		.file 19 "tmk_core/common/debug.h"
 2346               		.file 20 "tmk_core/common/led.h"
 2347               		.file 21 "tmk_core/common/action_macro.h"
 2348               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2      *ABS*:0000003e __SP_H__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:3      *ABS*:0000003d __SP_L__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:4      *ABS*:0000003f __SREG__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:6      *ABS*:00000001 __zero_reg__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:13     .text.action_exec:00000000 action_exec
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:94     .text.process_record_quantum:00000000 process_record_quantum
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:116    .text.process_record_tap_hint:00000000 process_record_tap_hint
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:141    .text.register_code:00000000 register_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2318   .rodata.CSWTCH.15:00000000 CSWTCH.15
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2291   .rodata.CSWTCH.16:00000000 CSWTCH.16
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:413    .text.unregister_code:00000000 unregister_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:581    .text.tap_code:00000000 tap_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:645    .text.register_mods:00000000 register_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:674    .text.unregister_mods:00000000 unregister_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:703    .text.process_action:00000000 process_action
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:1798   .text.process_record:00000000 process_record
                            *COM*:00000002 tp_buttons
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:1909   .text.process_record_nocache:00000000 process_record_nocache
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2326   .bss.disable_action_cache:00000000 disable_action_cache
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:1937   .text.register_weak_mods:00000000 register_weak_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:1966   .text.unregister_weak_mods:00000000 unregister_weak_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:1995   .text.clear_keyboard_but_mods_and_keys:00000000 clear_keyboard_but_mods_and_keys
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2034   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2054   .text.clear_keyboard:00000000 clear_keyboard
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2074   .text.is_tap_action:00000000 is_tap_action
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2162   .text.is_tap_key:00000000 is_tap_key
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2185   .text.debug_event:00000000 debug_event
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2227   .text.debug_record:00000000 debug_record
C:\Users\nonej\Documents\Keyboard\msys64\tmp\ccOn78LE.s:2271   .text.debug_action:00000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
