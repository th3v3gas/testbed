   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB108:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode) { return false; }
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #    endif
 102:tmk_core/common/action.c **** #endif
 103:tmk_core/common/action.c **** 
 104:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 105:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 105 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 105 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 105 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 106:tmk_core/common/action.c **** #else
 107:tmk_core/common/action.c ****     process_record(&record);
 108:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 109:tmk_core/common/action.c ****         dprint("processed: ");
 110:tmk_core/common/action.c ****         debug_record(record);
 111:tmk_core/common/action.c ****         dprintln();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #endif
 114:tmk_core/common/action.c **** }
  76               		.loc 1 114 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 105:tmk_core/common/action.c **** #else
  85               		.loc 1 105 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE108:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB110:
 115:tmk_core/common/action.c **** 
 116:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 117:tmk_core/common/action.c **** bool swap_hands = false;
 118:tmk_core/common/action.c **** bool swap_held  = false;
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** /** \brief Process Hand Swap
 121:tmk_core/common/action.c ****  *
 122:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 123:tmk_core/common/action.c ****  */
 124:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 125:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 126:tmk_core/common/action.c **** 
 127:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 128:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 129:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     if (do_swap) {
 132:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 133:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 134:tmk_core/common/action.c ****     } else {
 135:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 136:tmk_core/common/action.c ****     }
 137:tmk_core/common/action.c **** }
 138:tmk_core/common/action.c **** #endif
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 141:tmk_core/common/action.c **** bool disable_action_cache = false;
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 144:tmk_core/common/action.c ****     disable_action_cache = true;
 145:tmk_core/common/action.c ****     process_record(record);
 146:tmk_core/common/action.c ****     disable_action_cache = false;
 147:tmk_core/common/action.c **** }
 148:tmk_core/common/action.c **** #else
 149:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 150:tmk_core/common/action.c **** #endif
 151:tmk_core/common/action.c **** 
 152:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 152 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 152 74 view .LVU11
 104               		.loc 1 152 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 152 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE110:
 113               		.section	.text.process_record_tap_hint,"ax",@progbits
 114               	.global	process_record_tap_hint
 116               	process_record_tap_hint:
 117               	.LVL6:
 118               	.LFB111:
 153:tmk_core/common/action.c **** 
 154:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 155:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 156:tmk_core/common/action.c ****  *
 157:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 158:tmk_core/common/action.c ****  */
 159:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 119               		.loc 1 159 51 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 160:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 125               		.loc 1 160 5 view .LVU15
 126               		.loc 1 160 23 is_stmt 0 view .LVU16
 127 0000 FC01      		movw r30,r24
 128 0002 8081      		ld r24,Z
 129 0004 9181      		ldd r25,Z+1
 130               	.LVL7:
 131               		.loc 1 160 23 view .LVU17
 132 0006 0C94 0000 		jmp layer_switch_get_action
 133               	.LVL8:
 134               		.loc 1 160 23 view .LVU18
 135               		.cfi_endproc
 136               	.LFE111:
 138               		.section	.text.register_code,"ax",@progbits
 139               	.global	register_code
 141               	register_code:
 142               	.LVL9:
 143               	.LFB114:
 161:tmk_core/common/action.c **** 
 162:tmk_core/common/action.c ****     switch (action.kind.id) {
 163:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 164:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 165:tmk_core/common/action.c ****             switch (action.swap.code) {
 166:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 167:tmk_core/common/action.c ****                 default:
 168:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 169:tmk_core/common/action.c ****                     swap_held  = true;
 170:tmk_core/common/action.c ****             }
 171:tmk_core/common/action.c ****             break;
 172:tmk_core/common/action.c **** #    endif
 173:tmk_core/common/action.c ****     }
 174:tmk_core/common/action.c **** }
 175:tmk_core/common/action.c **** #endif
 176:tmk_core/common/action.c **** 
 177:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 178:tmk_core/common/action.c ****  *
 179:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 180:tmk_core/common/action.c ****  */
 181:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 182:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 183:tmk_core/common/action.c ****         return;
 184:tmk_core/common/action.c ****     }
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 187:tmk_core/common/action.c **** 
 188:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 189:tmk_core/common/action.c ****     dprint("ACTION: ");
 190:tmk_core/common/action.c ****     debug_action(action);
 191:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 192:tmk_core/common/action.c ****     dprint(" layer_state: ");
 193:tmk_core/common/action.c ****     layer_debug();
 194:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 195:tmk_core/common/action.c ****     default_layer_debug();
 196:tmk_core/common/action.c **** #endif
 197:tmk_core/common/action.c ****     dprintln();
 198:tmk_core/common/action.c **** 
 199:tmk_core/common/action.c ****     process_action(record, action);
 200:tmk_core/common/action.c **** }
 201:tmk_core/common/action.c **** 
 202:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 203:tmk_core/common/action.c ****  *
 204:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 205:tmk_core/common/action.c ****  */
 206:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 207:tmk_core/common/action.c ****     keyevent_t event = record->event;
 208:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 209:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 210:tmk_core/common/action.c **** #endif
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c ****     if (event.pressed) {
 213:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 214:tmk_core/common/action.c ****         clear_weak_mods();
 215:tmk_core/common/action.c ****     }
 216:tmk_core/common/action.c **** 
 217:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 218:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 219:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 220:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 221:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 222:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 223:tmk_core/common/action.c ****     }
 224:tmk_core/common/action.c **** #endif
 225:tmk_core/common/action.c **** 
 226:tmk_core/common/action.c ****     switch (action.kind.id) {
 227:tmk_core/common/action.c ****         /* Key and Mods */
 228:tmk_core/common/action.c ****         case ACT_LMODS:
 229:tmk_core/common/action.c ****         case ACT_RMODS: {
 230:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 231:tmk_core/common/action.c ****             if (event.pressed) {
 232:tmk_core/common/action.c ****                 if (mods) {
 233:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 234:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 235:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 236:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 237:tmk_core/common/action.c ****                         add_mods(mods);
 238:tmk_core/common/action.c ****                     } else {
 239:tmk_core/common/action.c ****                         add_weak_mods(mods);
 240:tmk_core/common/action.c ****                     }
 241:tmk_core/common/action.c ****                     send_keyboard_report();
 242:tmk_core/common/action.c ****                 }
 243:tmk_core/common/action.c ****                 register_code(action.key.code);
 244:tmk_core/common/action.c ****             } else {
 245:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 246:tmk_core/common/action.c ****                 if (mods) {
 247:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 248:tmk_core/common/action.c ****                         del_mods(mods);
 249:tmk_core/common/action.c ****                     } else {
 250:tmk_core/common/action.c ****                         del_weak_mods(mods);
 251:tmk_core/common/action.c ****                     }
 252:tmk_core/common/action.c ****                     send_keyboard_report();
 253:tmk_core/common/action.c ****                 }
 254:tmk_core/common/action.c ****             }
 255:tmk_core/common/action.c ****         } break;
 256:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 257:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 258:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 259:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 260:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 261:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 262:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 263:tmk_core/common/action.c ****                     // Oneshot modifier
 264:tmk_core/common/action.c ****                     if (event.pressed) {
 265:tmk_core/common/action.c ****                         if (tap_count == 0) {
 266:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 267:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 268:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 269:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 270:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 272:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 273:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 274:tmk_core/common/action.c ****                             clear_oneshot_mods();
 275:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 276:tmk_core/common/action.c ****                             register_mods(mods);
 277:tmk_core/common/action.c **** #        endif
 278:tmk_core/common/action.c ****                         } else {
 279:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 280:tmk_core/common/action.c ****                         }
 281:tmk_core/common/action.c ****                     } else {
 282:tmk_core/common/action.c ****                         if (tap_count == 0) {
 283:tmk_core/common/action.c ****                             clear_oneshot_mods();
 284:tmk_core/common/action.c ****                             unregister_mods(mods);
 285:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 286:tmk_core/common/action.c ****                             // Retain Oneshot mods
 287:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 288:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 289:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 290:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 291:tmk_core/common/action.c ****                                 unregister_mods(mods);
 292:tmk_core/common/action.c ****                             }
 293:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 294:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 295:tmk_core/common/action.c **** #        endif
 296:tmk_core/common/action.c ****                         } else {
 297:tmk_core/common/action.c ****                             clear_oneshot_mods();
 298:tmk_core/common/action.c ****                             unregister_mods(mods);
 299:tmk_core/common/action.c ****                         }
 300:tmk_core/common/action.c ****                     }
 301:tmk_core/common/action.c ****                     break;
 302:tmk_core/common/action.c **** #    endif
 303:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 304:tmk_core/common/action.c ****                     if (event.pressed) {
 305:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 306:tmk_core/common/action.c ****                             register_mods(mods);
 307:tmk_core/common/action.c ****                         }
 308:tmk_core/common/action.c ****                     } else {
 309:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 310:tmk_core/common/action.c ****                             unregister_mods(mods);
 311:tmk_core/common/action.c ****                         }
 312:tmk_core/common/action.c ****                     }
 313:tmk_core/common/action.c ****                     break;
 314:tmk_core/common/action.c ****                 default:
 315:tmk_core/common/action.c ****                     if (event.pressed) {
 316:tmk_core/common/action.c ****                         if (tap_count > 0) {
 317:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 318:tmk_core/common/action.c ****                             if (
 319:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 320:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event)) &&
 321:tmk_core/common/action.c **** #        endif
 322:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 323:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 324:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 325:tmk_core/common/action.c ****                                 record->tap.count = 0;
 326:tmk_core/common/action.c ****                                 register_mods(mods);
 327:tmk_core/common/action.c ****                             } else
 328:tmk_core/common/action.c **** #    endif
 329:tmk_core/common/action.c ****                             {
 330:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 331:tmk_core/common/action.c ****                                 register_code(action.key.code);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                         } else {
 334:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 335:tmk_core/common/action.c ****                             register_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     } else {
 338:tmk_core/common/action.c ****                         if (tap_count > 0) {
 339:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 340:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 341:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 342:tmk_core/common/action.c ****                             }
 343:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 344:tmk_core/common/action.c ****                         } else {
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 346:tmk_core/common/action.c ****                             unregister_mods(mods);
 347:tmk_core/common/action.c ****                         }
 348:tmk_core/common/action.c ****                     }
 349:tmk_core/common/action.c ****                     break;
 350:tmk_core/common/action.c ****             }
 351:tmk_core/common/action.c ****         } break;
 352:tmk_core/common/action.c **** #endif
 353:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 354:tmk_core/common/action.c ****         /* other HID usage */
 355:tmk_core/common/action.c ****         case ACT_USAGE:
 356:tmk_core/common/action.c ****             switch (action.usage.page) {
 357:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 358:tmk_core/common/action.c ****                     if (event.pressed) {
 359:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 360:tmk_core/common/action.c ****                     } else {
 361:tmk_core/common/action.c ****                         host_system_send(0);
 362:tmk_core/common/action.c ****                     }
 363:tmk_core/common/action.c ****                     break;
 364:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 365:tmk_core/common/action.c ****                     if (event.pressed) {
 366:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 367:tmk_core/common/action.c ****                     } else {
 368:tmk_core/common/action.c ****                         host_consumer_send(0);
 369:tmk_core/common/action.c ****                     }
 370:tmk_core/common/action.c ****                     break;
 371:tmk_core/common/action.c ****             }
 372:tmk_core/common/action.c ****             break;
 373:tmk_core/common/action.c **** #endif
 374:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 375:tmk_core/common/action.c ****         /* Mouse key */
 376:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 377:tmk_core/common/action.c ****             if (event.pressed) {
 378:tmk_core/common/action.c ****                 switch (action.key.code) {
 379:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 380:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 381:tmk_core/common/action.c ****                         break;
 382:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 383:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 386:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     default:
 389:tmk_core/common/action.c ****                         break;
 390:tmk_core/common/action.c ****                 }
 391:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 392:tmk_core/common/action.c ****                 mousekey_send();
 393:tmk_core/common/action.c ****             } else {
 394:tmk_core/common/action.c ****                 switch (action.key.code) {
 395:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 396:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 397:tmk_core/common/action.c ****                         break;
 398:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 399:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 400:tmk_core/common/action.c ****                         break;
 401:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 402:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 403:tmk_core/common/action.c ****                         break;
 404:tmk_core/common/action.c ****                     default:
 405:tmk_core/common/action.c ****                         break;
 406:tmk_core/common/action.c ****                 }
 407:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 408:tmk_core/common/action.c ****                 mousekey_send();
 409:tmk_core/common/action.c ****             }
 410:tmk_core/common/action.c ****             break;
 411:tmk_core/common/action.c **** #endif
 412:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 413:tmk_core/common/action.c ****         case ACT_LAYER:
 414:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 415:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 416:tmk_core/common/action.c ****                 if (!event.pressed) {
 417:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 418:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 419:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 420:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 421:tmk_core/common/action.c ****                         case OP_BIT_AND:
 422:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 423:tmk_core/common/action.c ****                             break;
 424:tmk_core/common/action.c ****                         case OP_BIT_OR:
 425:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 426:tmk_core/common/action.c ****                             break;
 427:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 428:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 429:tmk_core/common/action.c ****                             break;
 430:tmk_core/common/action.c ****                         case OP_BIT_SET:
 431:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 432:tmk_core/common/action.c ****                             break;
 433:tmk_core/common/action.c ****                     }
 434:tmk_core/common/action.c ****                 }
 435:tmk_core/common/action.c ****             } else {
 436:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 437:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 438:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 439:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 440:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 441:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 442:tmk_core/common/action.c ****                         case OP_BIT_AND:
 443:tmk_core/common/action.c ****                             layer_and(bits | mask);
 444:tmk_core/common/action.c ****                             break;
 445:tmk_core/common/action.c ****                         case OP_BIT_OR:
 446:tmk_core/common/action.c ****                             layer_or(bits | mask);
 447:tmk_core/common/action.c ****                             break;
 448:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 449:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 450:tmk_core/common/action.c ****                             break;
 451:tmk_core/common/action.c ****                         case OP_BIT_SET:
 452:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 453:tmk_core/common/action.c ****                             break;
 454:tmk_core/common/action.c ****                     }
 455:tmk_core/common/action.c ****                 }
 456:tmk_core/common/action.c ****             }
 457:tmk_core/common/action.c ****             break;
 458:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 459:tmk_core/common/action.c ****             if (event.pressed) {
 460:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 461:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 462:tmk_core/common/action.c ****             } else {
 463:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 464:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 465:tmk_core/common/action.c ****             }
 466:tmk_core/common/action.c ****             break;
 467:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 468:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 469:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 470:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 471:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 472:tmk_core/common/action.c ****                     /* tap toggle */
 473:tmk_core/common/action.c ****                     if (event.pressed) {
 474:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 475:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 476:tmk_core/common/action.c ****                         }
 477:tmk_core/common/action.c ****                     } else {
 478:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 479:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 480:tmk_core/common/action.c ****                         }
 481:tmk_core/common/action.c ****                     }
 482:tmk_core/common/action.c ****                     break;
 483:tmk_core/common/action.c ****                 case OP_ON_OFF:
 484:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 485:tmk_core/common/action.c ****                     break;
 486:tmk_core/common/action.c ****                 case OP_OFF_ON:
 487:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 488:tmk_core/common/action.c ****                     break;
 489:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 490:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 491:tmk_core/common/action.c ****                     break;
 492:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 493:tmk_core/common/action.c ****                 case OP_ONESHOT:
 494:tmk_core/common/action.c ****                     // Oneshot modifier
 495:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 496:tmk_core/common/action.c ****                     do_release_oneshot = false;
 497:tmk_core/common/action.c ****                     if (event.pressed) {
 498:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 499:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 500:tmk_core/common/action.c ****                             reset_oneshot_layer();
 501:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 502:tmk_core/common/action.c ****                             break;
 503:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 504:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 505:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 506:tmk_core/common/action.c ****                         }
 507:tmk_core/common/action.c ****                     } else {
 508:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 509:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 510:tmk_core/common/action.c ****                             reset_oneshot_layer();
 511:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 512:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 513:tmk_core/common/action.c ****                         } else {
 514:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 515:tmk_core/common/action.c ****                         }
 516:tmk_core/common/action.c ****                     }
 517:tmk_core/common/action.c **** #            else
 518:tmk_core/common/action.c ****                     if (event.pressed) {
 519:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 520:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 521:tmk_core/common/action.c ****                     } else {
 522:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 523:tmk_core/common/action.c ****                         if (tap_count > 1) {
 524:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 525:tmk_core/common/action.c ****                         }
 526:tmk_core/common/action.c ****                     }
 527:tmk_core/common/action.c **** #            endif
 528:tmk_core/common/action.c ****                     break;
 529:tmk_core/common/action.c **** #        endif
 530:tmk_core/common/action.c ****                 default:
 531:tmk_core/common/action.c ****                     /* tap key */
 532:tmk_core/common/action.c ****                     if (event.pressed) {
 533:tmk_core/common/action.c ****                         if (tap_count > 0) {
 534:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 535:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 536:tmk_core/common/action.c ****                         } else {
 537:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 538:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 539:tmk_core/common/action.c ****                         }
 540:tmk_core/common/action.c ****                     } else {
 541:tmk_core/common/action.c ****                         if (tap_count > 0) {
 542:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 543:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 544:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 545:tmk_core/common/action.c ****                             } else {
 546:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 547:tmk_core/common/action.c ****                             }
 548:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 549:tmk_core/common/action.c ****                         } else {
 550:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 551:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 552:tmk_core/common/action.c ****                         }
 553:tmk_core/common/action.c ****                     }
 554:tmk_core/common/action.c ****                     break;
 555:tmk_core/common/action.c ****             }
 556:tmk_core/common/action.c ****             break;
 557:tmk_core/common/action.c **** #    endif
 558:tmk_core/common/action.c **** #endif
 559:tmk_core/common/action.c ****             /* Extentions */
 560:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 561:tmk_core/common/action.c ****         case ACT_MACRO:
 562:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 563:tmk_core/common/action.c ****             break;
 564:tmk_core/common/action.c **** #endif
 565:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) || defined(LED_MATRIX_ENABLE)
 566:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 567:tmk_core/common/action.c ****             if (!event.pressed) {
 568:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 569:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 570:tmk_core/common/action.c ****                         backlight_increase();
 571:tmk_core/common/action.c ****                         break;
 572:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 573:tmk_core/common/action.c ****                         backlight_decrease();
 574:tmk_core/common/action.c ****                         break;
 575:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 576:tmk_core/common/action.c ****                         backlight_toggle();
 577:tmk_core/common/action.c ****                         break;
 578:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 579:tmk_core/common/action.c ****                         backlight_step();
 580:tmk_core/common/action.c ****                         break;
 581:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 582:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 583:tmk_core/common/action.c ****                         break;
 584:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 585:tmk_core/common/action.c ****                         backlight_level(0);
 586:tmk_core/common/action.c ****                         break;
 587:tmk_core/common/action.c ****                 }
 588:tmk_core/common/action.c ****             }
 589:tmk_core/common/action.c ****             break;
 590:tmk_core/common/action.c **** #endif
 591:tmk_core/common/action.c ****         case ACT_COMMAND:
 592:tmk_core/common/action.c ****             break;
 593:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 594:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 595:tmk_core/common/action.c ****             switch (action.swap.code) {
 596:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 597:tmk_core/common/action.c ****                     if (event.pressed) {
 598:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 599:tmk_core/common/action.c ****                     }
 600:tmk_core/common/action.c ****                     break;
 601:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 602:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 605:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_ON:
 608:tmk_core/common/action.c ****                     if (!event.pressed) {
 609:tmk_core/common/action.c ****                         swap_hands = true;
 610:tmk_core/common/action.c ****                     }
 611:tmk_core/common/action.c ****                     break;
 612:tmk_core/common/action.c ****                 case OP_SH_OFF:
 613:tmk_core/common/action.c ****                     if (!event.pressed) {
 614:tmk_core/common/action.c ****                         swap_hands = false;
 615:tmk_core/common/action.c ****                     }
 616:tmk_core/common/action.c ****                     break;
 617:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 618:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 619:tmk_core/common/action.c ****                     /* tap toggle */
 620:tmk_core/common/action.c **** 
 621:tmk_core/common/action.c ****                     if (event.pressed) {
 622:tmk_core/common/action.c ****                         if (swap_held) {
 623:tmk_core/common/action.c ****                             swap_held = false;
 624:tmk_core/common/action.c ****                         } else {
 625:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 626:tmk_core/common/action.c ****                         }
 627:tmk_core/common/action.c ****                     } else {
 628:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 629:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 630:tmk_core/common/action.c ****                         }
 631:tmk_core/common/action.c ****                     }
 632:tmk_core/common/action.c ****                     break;
 633:tmk_core/common/action.c ****                 default:
 634:tmk_core/common/action.c ****                     /* tap key */
 635:tmk_core/common/action.c ****                     if (tap_count > 0) {
 636:tmk_core/common/action.c ****                         if (swap_held) {
 637:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 638:tmk_core/common/action.c ****                             swap_held  = false;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                         if (event.pressed) {
 641:tmk_core/common/action.c ****                             register_code(action.swap.code);
 642:tmk_core/common/action.c ****                         } else {
 643:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 644:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 645:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 646:tmk_core/common/action.c ****                         }
 647:tmk_core/common/action.c ****                     } else {
 648:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 649:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:tmk_core/common/action.c ****                             swap_held  = false;
 651:tmk_core/common/action.c ****                         }
 652:tmk_core/common/action.c ****                     }
 653:tmk_core/common/action.c **** #    endif
 654:tmk_core/common/action.c ****             }
 655:tmk_core/common/action.c **** #endif
 656:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 657:tmk_core/common/action.c ****         case ACT_FUNCTION:
 658:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 659:tmk_core/common/action.c ****             break;
 660:tmk_core/common/action.c **** #endif
 661:tmk_core/common/action.c ****         default:
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****     }
 664:tmk_core/common/action.c **** 
 665:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 666:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 667:tmk_core/common/action.c ****     switch (action.kind.id) {
 668:tmk_core/common/action.c ****         case ACT_LAYER:
 669:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 670:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 671:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 672:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 673:tmk_core/common/action.c **** #    endif
 674:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****         default:
 677:tmk_core/common/action.c ****             break;
 678:tmk_core/common/action.c ****     }
 679:tmk_core/common/action.c **** #endif
 680:tmk_core/common/action.c **** 
 681:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 682:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 683:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 684:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 685:tmk_core/common/action.c ****     } else {
 686:tmk_core/common/action.c ****         if (event.pressed) {
 687:tmk_core/common/action.c ****             if (tap_count > 0) {
 688:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 689:tmk_core/common/action.c ****             } else {
 690:tmk_core/common/action.c ****             }
 691:tmk_core/common/action.c ****         } else {
 692:tmk_core/common/action.c ****             if (tap_count > 0) {
 693:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 694:tmk_core/common/action.c ****             } else {
 695:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 696:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 697:tmk_core/common/action.c ****                 }
 698:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 699:tmk_core/common/action.c ****             }
 700:tmk_core/common/action.c ****         }
 701:tmk_core/common/action.c ****     }
 702:tmk_core/common/action.c **** #    endif
 703:tmk_core/common/action.c **** #endif
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 706:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 707:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 708:tmk_core/common/action.c ****      */
 709:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 710:tmk_core/common/action.c ****         record->event.pressed = false;
 711:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 712:tmk_core/common/action.c ****         process_record(record);
 713:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #endif
 716:tmk_core/common/action.c **** }
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 719:tmk_core/common/action.c ****  *
 720:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 721:tmk_core/common/action.c ****  */
 722:tmk_core/common/action.c **** void register_code(uint8_t code) {
 144               		.loc 1 722 34 is_stmt 1 view -0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
 723:tmk_core/common/action.c ****     if (code == KC_NO) {
 150               		.loc 1 723 5 view .LVU20
 151               		.loc 1 723 8 is_stmt 0 view .LVU21
 152 0000 8823      		tst r24
 153 0002 01F0      		breq .L4
 724:tmk_core/common/action.c ****         return;
 725:tmk_core/common/action.c ****     }
 726:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 727:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 728:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 729:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 730:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 731:tmk_core/common/action.c **** #    endif
 732:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 733:tmk_core/common/action.c ****         send_keyboard_report();
 734:tmk_core/common/action.c ****         wait_ms(100);
 735:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 736:tmk_core/common/action.c ****         send_keyboard_report();
 737:tmk_core/common/action.c ****     }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 740:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 741:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 742:tmk_core/common/action.c **** #    endif
 743:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 744:tmk_core/common/action.c ****         send_keyboard_report();
 745:tmk_core/common/action.c ****         wait_ms(100);
 746:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 747:tmk_core/common/action.c ****         send_keyboard_report();
 748:tmk_core/common/action.c ****     }
 749:tmk_core/common/action.c **** 
 750:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 751:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 753:tmk_core/common/action.c **** #    endif
 754:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 755:tmk_core/common/action.c ****         send_keyboard_report();
 756:tmk_core/common/action.c ****         wait_ms(100);
 757:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 758:tmk_core/common/action.c ****         send_keyboard_report();
 759:tmk_core/common/action.c ****     }
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c **** 
 762:tmk_core/common/action.c ****     else if
 154               		.loc 1 762 10 is_stmt 1 view .LVU22
 763:tmk_core/common/action.c ****         IS_KEY(code) {
 155               		.loc 1 763 9 is_stmt 0 view .LVU23
 156 0004 9CEF      		ldi r25,lo8(-4)
 157 0006 980F      		add r25,r24
 158 0008 913A      		cpi r25,lo8(-95)
 159 000a 00F4      		brsh .L6
 764:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 765:tmk_core/common/action.c ****             if (command_proc(code)) return;
 160               		.loc 1 765 13 is_stmt 1 view .LVU24
 766:tmk_core/common/action.c **** 
 767:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 768:tmk_core/common/action.c **** /* TODO: remove
 769:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 770:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 771:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 772:tmk_core/common/action.c **** 
 773:tmk_core/common/action.c ****             add_key(code);
 774:tmk_core/common/action.c ****             send_keyboard_report();
 775:tmk_core/common/action.c **** 
 776:tmk_core/common/action.c ****             set_mods(tmp_mods);
 777:tmk_core/common/action.c ****             send_keyboard_report();
 778:tmk_core/common/action.c ****             oneshot_cancel();
 779:tmk_core/common/action.c ****         } else
 780:tmk_core/common/action.c **** */
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c ****             {
 783:tmk_core/common/action.c ****                 add_key(code);
 161               		.loc 1 783 17 view .LVU25
 162 000c 0E94 0000 		call add_key
 163               	.LVL10:
 784:tmk_core/common/action.c ****                 send_keyboard_report();
 164               		.loc 1 784 17 view .LVU26
 165               	.L12:
 785:tmk_core/common/action.c ****             }
 786:tmk_core/common/action.c ****         }
 787:tmk_core/common/action.c ****     else if
 788:tmk_core/common/action.c ****         IS_MOD(code) {
 789:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 790:tmk_core/common/action.c ****             send_keyboard_report();
 166               		.loc 1 790 13 view .LVU27
 167 0010 0C94 0000 		jmp send_keyboard_report
 168               	.LVL11:
 169               	.L6:
 787:tmk_core/common/action.c ****         IS_MOD(code) {
 170               		.loc 1 787 10 view .LVU28
 788:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 171               		.loc 1 788 9 is_stmt 0 view .LVU29
 172 0014 90E2      		ldi r25,lo8(32)
 173 0016 980F      		add r25,r24
 174 0018 9830      		cpi r25,lo8(8)
 175 001a 00F4      		brsh .L7
 789:tmk_core/common/action.c ****             send_keyboard_report();
 176               		.loc 1 789 13 is_stmt 1 view .LVU30
 789:tmk_core/common/action.c ****             send_keyboard_report();
 177               		.loc 1 789 22 is_stmt 0 view .LVU31
 178 001c E82F      		mov r30,r24
 179 001e E770      		andi r30,lo8(7)
 789:tmk_core/common/action.c ****             send_keyboard_report();
 180               		.loc 1 789 13 view .LVU32
 181 0020 81E0      		ldi r24,lo8(1)
 182               	.LVL12:
 789:tmk_core/common/action.c ****             send_keyboard_report();
 183               		.loc 1 789 13 view .LVU33
 184 0022 00C0      		rjmp 2f
 185               		1:
 186 0024 880F      		lsl r24
 187               		2:
 188 0026 EA95      		dec r30
 189 0028 02F4      		brpl 1b
 190 002a 0E94 0000 		call add_mods
 191               	.LVL13:
 192 002e 00C0      		rjmp .L12
 193               	.LVL14:
 194               	.L7:
 791:tmk_core/common/action.c ****         }
 792:tmk_core/common/action.c ****     else if
 195               		.loc 1 792 10 is_stmt 1 view .LVU34
 793:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 196               		.loc 1 793 9 is_stmt 0 view .LVU35
 197 0030 EBE5      		ldi r30,lo8(91)
 198 0032 E80F      		add r30,r24
 199 0034 E330      		cpi r30,lo8(3)
 200 0036 00F4      		brsh .L8
 201               		.loc 1 793 27 is_stmt 1 view .LVU36
 202               	.LVL15:
 203               	.LBB20:
 204               	.LBI20:
 205               		.file 2 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #ifndef REPORT_H
  19:tmk_core/common/report.h **** #define REPORT_H
  20:tmk_core/common/report.h **** 
  21:tmk_core/common/report.h **** #include <stdint.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** /* report id */
  25:tmk_core/common/report.h **** #define REPORT_ID_KEYBOARD 1
  26:tmk_core/common/report.h **** #define REPORT_ID_MOUSE 2
  27:tmk_core/common/report.h **** #define REPORT_ID_SYSTEM 3
  28:tmk_core/common/report.h **** #define REPORT_ID_CONSUMER 4
  29:tmk_core/common/report.h **** #define REPORT_ID_NKRO 5
  30:tmk_core/common/report.h **** 
  31:tmk_core/common/report.h **** /* mouse buttons */
  32:tmk_core/common/report.h **** #define MOUSE_BTN1 (1 << 0)
  33:tmk_core/common/report.h **** #define MOUSE_BTN2 (1 << 1)
  34:tmk_core/common/report.h **** #define MOUSE_BTN3 (1 << 2)
  35:tmk_core/common/report.h **** #define MOUSE_BTN4 (1 << 3)
  36:tmk_core/common/report.h **** #define MOUSE_BTN5 (1 << 4)
  37:tmk_core/common/report.h **** 
  38:tmk_core/common/report.h **** /* Consumer Page(0x0C)
  39:tmk_core/common/report.h ****  * following are supported by Windows: http://msdn.microsoft.com/en-us/windows/hardware/gg463372.as
  40:tmk_core/common/report.h ****  * see also https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/display-brightness-contro
  41:tmk_core/common/report.h ****  */
  42:tmk_core/common/report.h **** #define AUDIO_MUTE 0x00E2
  43:tmk_core/common/report.h **** #define AUDIO_VOL_UP 0x00E9
  44:tmk_core/common/report.h **** #define AUDIO_VOL_DOWN 0x00EA
  45:tmk_core/common/report.h **** #define TRANSPORT_NEXT_TRACK 0x00B5
  46:tmk_core/common/report.h **** #define TRANSPORT_PREV_TRACK 0x00B6
  47:tmk_core/common/report.h **** #define TRANSPORT_STOP 0x00B7
  48:tmk_core/common/report.h **** #define TRANSPORT_STOP_EJECT 0x00CC
  49:tmk_core/common/report.h **** #define TRANSPORT_PLAY_PAUSE 0x00CD
  50:tmk_core/common/report.h **** #define BRIGHTNESS_UP 0x006F
  51:tmk_core/common/report.h **** #define BRIGHTNESS_DOWN 0x0070
  52:tmk_core/common/report.h **** /* application launch */
  53:tmk_core/common/report.h **** #define AL_CC_CONFIG 0x0183
  54:tmk_core/common/report.h **** #define AL_EMAIL 0x018A
  55:tmk_core/common/report.h **** #define AL_CALCULATOR 0x0192
  56:tmk_core/common/report.h **** #define AL_LOCAL_BROWSER 0x0194
  57:tmk_core/common/report.h **** /* application control */
  58:tmk_core/common/report.h **** #define AC_SEARCH 0x0221
  59:tmk_core/common/report.h **** #define AC_HOME 0x0223
  60:tmk_core/common/report.h **** #define AC_BACK 0x0224
  61:tmk_core/common/report.h **** #define AC_FORWARD 0x0225
  62:tmk_core/common/report.h **** #define AC_STOP 0x0226
  63:tmk_core/common/report.h **** #define AC_REFRESH 0x0227
  64:tmk_core/common/report.h **** #define AC_BOOKMARKS 0x022A
  65:tmk_core/common/report.h **** /* supplement for Bluegiga iWRAP HID(not supported by Windows?) */
  66:tmk_core/common/report.h **** #define AL_LOCK 0x019E
  67:tmk_core/common/report.h **** #define TRANSPORT_RECORD 0x00B2
  68:tmk_core/common/report.h **** #define TRANSPORT_FAST_FORWARD 0x00B3
  69:tmk_core/common/report.h **** #define TRANSPORT_REWIND 0x00B4
  70:tmk_core/common/report.h **** #define TRANSPORT_EJECT 0x00B8
  71:tmk_core/common/report.h **** #define AC_MINIMIZE 0x0206
  72:tmk_core/common/report.h **** 
  73:tmk_core/common/report.h **** /* Generic Desktop Page(0x01) - system power control */
  74:tmk_core/common/report.h **** #define SYSTEM_POWER_DOWN 0x0081
  75:tmk_core/common/report.h **** #define SYSTEM_SLEEP 0x0082
  76:tmk_core/common/report.h **** #define SYSTEM_WAKE_UP 0x0083
  77:tmk_core/common/report.h **** 
  78:tmk_core/common/report.h **** #define NKRO_SHARED_EP
  79:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
  80:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
  81:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
  82:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
  83:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
  84:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
  85:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
  86:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
  87:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
  88:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
  89:tmk_core/common/report.h **** #    else
  90:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
  91:tmk_core/common/report.h **** #    endif
  92:tmk_core/common/report.h **** #endif
  93:tmk_core/common/report.h **** 
  94:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
  95:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
  96:tmk_core/common/report.h **** #else
  97:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
  98:tmk_core/common/report.h **** #endif
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 103:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 104:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 105:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 106:tmk_core/common/report.h **** #endif
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** #ifdef __cplusplus
 109:tmk_core/common/report.h **** extern "C" {
 110:tmk_core/common/report.h **** #endif
 111:tmk_core/common/report.h **** 
 112:tmk_core/common/report.h **** /*
 113:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 114:tmk_core/common/report.h ****  *
 115:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 116:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 117:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 118:tmk_core/common/report.h ****  *
 119:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 120:tmk_core/common/report.h ****  *
 121:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 122:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 123:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 124:tmk_core/common/report.h ****  *
 125:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 126:tmk_core/common/report.h ****  *
 127:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 128:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 129:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 130:tmk_core/common/report.h ****  *
 131:tmk_core/common/report.h ****  */
 132:tmk_core/common/report.h **** typedef union {
 133:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 134:tmk_core/common/report.h ****     struct {
 135:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 136:tmk_core/common/report.h ****         uint8_t report_id;
 137:tmk_core/common/report.h **** #endif
 138:tmk_core/common/report.h ****         uint8_t mods;
 139:tmk_core/common/report.h ****         uint8_t reserved;
 140:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 141:tmk_core/common/report.h ****     };
 142:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 143:tmk_core/common/report.h ****     struct nkro_report {
 144:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 145:tmk_core/common/report.h ****         uint8_t report_id;
 146:tmk_core/common/report.h **** #    endif
 147:tmk_core/common/report.h ****         uint8_t mods;
 148:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 149:tmk_core/common/report.h ****     } nkro;
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 152:tmk_core/common/report.h **** 
 153:tmk_core/common/report.h **** typedef struct {
 154:tmk_core/common/report.h ****     uint8_t  report_id;
 155:tmk_core/common/report.h ****     uint16_t usage;
 156:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 157:tmk_core/common/report.h **** 
 158:tmk_core/common/report.h **** typedef struct {
 159:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 160:tmk_core/common/report.h ****     uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****     uint8_t buttons;
 163:tmk_core/common/report.h ****     int8_t  x;
 164:tmk_core/common/report.h ****     int8_t  y;
 165:tmk_core/common/report.h ****     int8_t  v;
 166:tmk_core/common/report.h ****     int8_t  h;
 167:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 168:tmk_core/common/report.h **** 
 169:tmk_core/common/report.h **** /* keycode to system usage */
 170:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 206               		.loc 2 170 24 view .LVU37
 207               	.LBE20:
 171:tmk_core/common/report.h ****     switch (key) {
 208               		.loc 2 171 5 view .LVU38
 209               		.loc 1 793 27 is_stmt 0 view .LVU39
 210 0038 F0E0      		ldi r31,0
 211 003a E050      		subi r30,lo8(-(CSWTCH.9))
 212 003c F040      		sbci r31,hi8(-(CSWTCH.9))
 213 003e 8081      		ld r24,Z
 214               	.LVL16:
 215               		.loc 1 793 27 view .LVU40
 216 0040 90E0      		ldi r25,0
 217 0042 0C94 0000 		jmp host_system_send
 218               	.LVL17:
 219               	.L8:
 794:tmk_core/common/action.c ****     else if
 220               		.loc 1 794 10 is_stmt 1 view .LVU41
 795:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 221               		.loc 1 795 9 is_stmt 0 view .LVU42
 222 0046 885A      		subi r24,lo8(-(88))
 223               	.LVL18:
 224               		.loc 1 795 9 view .LVU43
 225 0048 8731      		cpi r24,lo8(23)
 226 004a 00F4      		brsh .L4
 227               		.loc 1 795 29 is_stmt 1 view .LVU44
 228               	.LVL19:
 229               	.LBB21:
 230               	.LBI21:
 172:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 173:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 174:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 175:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 176:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 177:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 178:tmk_core/common/report.h ****         default:
 179:tmk_core/common/report.h ****             return 0;
 180:tmk_core/common/report.h ****     }
 181:tmk_core/common/report.h **** }
 182:tmk_core/common/report.h **** 
 183:tmk_core/common/report.h **** /* keycode to consumer usage */
 184:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 231               		.loc 2 184 24 view .LVU45
 232               	.LBE21:
 185:tmk_core/common/report.h ****     switch (key) {
 233               		.loc 2 185 5 view .LVU46
 234               		.loc 1 795 29 is_stmt 0 view .LVU47
 235 004c E82F      		mov r30,r24
 236 004e F0E0      		ldi r31,0
 237 0050 EE0F      		lsl r30
 238 0052 FF1F      		rol r31
 239               	.LVL20:
 240               		.loc 1 795 29 view .LVU48
 241 0054 E050      		subi r30,lo8(-(CSWTCH.10))
 242 0056 F040      		sbci r31,hi8(-(CSWTCH.10))
 243 0058 8081      		ld r24,Z
 244 005a 9181      		ldd r25,Z+1
 245 005c 0C94 0000 		jmp host_consumer_send
 246               	.LVL21:
 247               	.L4:
 248               	/* epilogue start */
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 798:tmk_core/common/action.c ****     else if
 799:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 800:tmk_core/common/action.c ****             mousekey_on(code);
 801:tmk_core/common/action.c ****             mousekey_send();
 802:tmk_core/common/action.c ****         }
 803:tmk_core/common/action.c **** #endif
 804:tmk_core/common/action.c **** }
 249               		.loc 1 804 1 view .LVU49
 250 0060 0895      		ret
 251               		.cfi_endproc
 252               	.LFE114:
 254               		.section	.text.unregister_code,"ax",@progbits
 255               	.global	unregister_code
 257               	unregister_code:
 258               	.LVL22:
 259               	.LFB115:
 805:tmk_core/common/action.c **** 
 806:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 807:tmk_core/common/action.c ****  *
 808:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 809:tmk_core/common/action.c ****  */
 810:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 260               		.loc 1 810 36 is_stmt 1 view -0
 261               		.cfi_startproc
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
 811:tmk_core/common/action.c ****     if (code == KC_NO) {
 266               		.loc 1 811 5 view .LVU51
 267               		.loc 1 811 8 is_stmt 0 view .LVU52
 268 0000 8823      		tst r24
 269 0002 01F0      		breq .L13
 812:tmk_core/common/action.c ****         return;
 813:tmk_core/common/action.c ****     }
 814:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 815:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 816:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 817:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 818:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 819:tmk_core/common/action.c **** #    endif
 820:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 821:tmk_core/common/action.c ****         send_keyboard_report();
 822:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 823:tmk_core/common/action.c ****         send_keyboard_report();
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c **** 
 826:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 827:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 828:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 829:tmk_core/common/action.c **** #    endif
 830:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 831:tmk_core/common/action.c ****         send_keyboard_report();
 832:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 833:tmk_core/common/action.c ****         send_keyboard_report();
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** 
 836:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 837:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 838:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 839:tmk_core/common/action.c **** #    endif
 840:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 841:tmk_core/common/action.c ****         send_keyboard_report();
 842:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 843:tmk_core/common/action.c ****         send_keyboard_report();
 844:tmk_core/common/action.c ****     }
 845:tmk_core/common/action.c **** #endif
 846:tmk_core/common/action.c **** 
 847:tmk_core/common/action.c ****     else if
 270               		.loc 1 847 10 is_stmt 1 view .LVU53
 848:tmk_core/common/action.c ****         IS_KEY(code) {
 271               		.loc 1 848 9 is_stmt 0 view .LVU54
 272 0004 9CEF      		ldi r25,lo8(-4)
 273 0006 980F      		add r25,r24
 274 0008 913A      		cpi r25,lo8(-95)
 275 000a 00F4      		brsh .L15
 849:tmk_core/common/action.c ****             del_key(code);
 276               		.loc 1 849 13 is_stmt 1 view .LVU55
 277 000c 0E94 0000 		call del_key
 278               	.LVL23:
 850:tmk_core/common/action.c ****             send_keyboard_report();
 279               		.loc 1 850 13 view .LVU56
 280               	.L21:
 851:tmk_core/common/action.c ****         }
 852:tmk_core/common/action.c ****     else if
 853:tmk_core/common/action.c ****         IS_MOD(code) {
 854:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 855:tmk_core/common/action.c ****             send_keyboard_report();
 281               		.loc 1 855 13 view .LVU57
 282 0010 0C94 0000 		jmp send_keyboard_report
 283               	.LVL24:
 284               	.L15:
 852:tmk_core/common/action.c ****         IS_MOD(code) {
 285               		.loc 1 852 10 view .LVU58
 853:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 286               		.loc 1 853 9 is_stmt 0 view .LVU59
 287 0014 90E2      		ldi r25,lo8(32)
 288 0016 980F      		add r25,r24
 289 0018 9830      		cpi r25,lo8(8)
 290 001a 00F4      		brsh .L16
 854:tmk_core/common/action.c ****             send_keyboard_report();
 291               		.loc 1 854 13 is_stmt 1 view .LVU60
 854:tmk_core/common/action.c ****             send_keyboard_report();
 292               		.loc 1 854 22 is_stmt 0 view .LVU61
 293 001c 8770      		andi r24,lo8(7)
 294               	.LVL25:
 854:tmk_core/common/action.c ****             send_keyboard_report();
 295               		.loc 1 854 13 view .LVU62
 296 001e 91E0      		ldi r25,lo8(1)
 297 0020 00C0      		rjmp 2f
 298               		1:
 299 0022 990F      		lsl r25
 300               		2:
 301 0024 8A95      		dec r24
 302 0026 02F4      		brpl 1b
 303 0028 892F      		mov r24,r25
 304 002a 0E94 0000 		call del_mods
 305               	.LVL26:
 306 002e 00C0      		rjmp .L21
 307               	.LVL27:
 308               	.L16:
 856:tmk_core/common/action.c ****         }
 857:tmk_core/common/action.c ****     else if
 309               		.loc 1 857 10 is_stmt 1 view .LVU63
 858:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 310               		.loc 1 858 9 is_stmt 0 view .LVU64
 311 0030 9BE5      		ldi r25,lo8(91)
 312 0032 980F      		add r25,r24
 313 0034 9330      		cpi r25,lo8(3)
 314 0036 00F4      		brsh .L17
 315               		.loc 1 858 27 is_stmt 1 discriminator 1 view .LVU65
 316 0038 90E0      		ldi r25,0
 317 003a 80E0      		ldi r24,0
 318               	.LVL28:
 319               		.loc 1 858 27 is_stmt 0 discriminator 1 view .LVU66
 320 003c 0C94 0000 		jmp host_system_send
 321               	.LVL29:
 322               	.L17:
 859:tmk_core/common/action.c ****     else if
 323               		.loc 1 859 10 is_stmt 1 view .LVU67
 860:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 324               		.loc 1 860 9 is_stmt 0 view .LVU68
 325 0040 885A      		subi r24,lo8(-(88))
 326               	.LVL30:
 327               		.loc 1 860 9 view .LVU69
 328 0042 8731      		cpi r24,lo8(23)
 329 0044 00F4      		brsh .L13
 330               		.loc 1 860 29 is_stmt 1 discriminator 1 view .LVU70
 331 0046 90E0      		ldi r25,0
 332 0048 80E0      		ldi r24,0
 333               	.LVL31:
 334               		.loc 1 860 29 is_stmt 0 discriminator 1 view .LVU71
 335 004a 0C94 0000 		jmp host_consumer_send
 336               	.LVL32:
 337               	.L13:
 338               	/* epilogue start */
 861:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 862:tmk_core/common/action.c ****     else if
 863:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 864:tmk_core/common/action.c ****             mousekey_off(code);
 865:tmk_core/common/action.c ****             mousekey_send();
 866:tmk_core/common/action.c ****         }
 867:tmk_core/common/action.c **** #endif
 868:tmk_core/common/action.c **** }
 339               		.loc 1 868 1 view .LVU72
 340 004e 0895      		ret
 341               		.cfi_endproc
 342               	.LFE115:
 344               		.section	.text.tap_code,"ax",@progbits
 345               	.global	tap_code
 347               	tap_code:
 348               	.LVL33:
 349               	.LFB116:
 869:tmk_core/common/action.c **** 
 870:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 871:tmk_core/common/action.c ****  *
 872:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 873:tmk_core/common/action.c ****  */
 874:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 350               		.loc 1 874 29 is_stmt 1 view -0
 351               		.cfi_startproc
 352               		.loc 1 874 29 is_stmt 0 view .LVU74
 353 0000 CF93      		push r28
 354               	.LCFI4:
 355               		.cfi_def_cfa_offset 3
 356               		.cfi_offset 28, -2
 357               	/* prologue: function */
 358               	/* frame size = 0 */
 359               	/* stack size = 1 */
 360               	.L__stack_usage = 1
 361 0002 C82F      		mov r28,r24
 875:tmk_core/common/action.c ****     register_code(code);
 362               		.loc 1 875 5 is_stmt 1 view .LVU75
 363 0004 0E94 0000 		call register_code
 364               	.LVL34:
 876:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 365               		.loc 1 876 5 view .LVU76
 366               		.loc 1 876 8 is_stmt 0 view .LVU77
 367 0008 C933      		cpi r28,lo8(57)
 368 000a 01F4      		brne .L24
 877:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 369               		.loc 1 877 9 is_stmt 1 view .LVU78
 370               	.LVL35:
 371               	.LBB22:
 372               	.LBI22:
 373               		.file 3 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchain
   1:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 374               		.loc 3 166 1 view .LVU79
 375               	.LBB23:
 167:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 376               		.loc 3 168 2 view .LVU80
 169:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 377               		.loc 3 172 2 view .LVU81
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 378               		.loc 3 173 2 view .LVU82
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 379               		.loc 3 174 2 view .LVU83
 175:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 380               		.loc 3 184 3 view .LVU84
 185:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 381               		.loc 3 187 2 view .LVU85
 382 000c 2FEF      		ldi r18,lo8(255999)
 383 000e 87EE      		ldi r24,hi8(255999)
 384 0010 93E0      		ldi r25,hlo8(255999)
 385 0012 2150      	1:	subi r18,1
 386 0014 8040      		sbci r24,0
 387 0016 9040      		sbci r25,0
 388 0018 01F4      		brne 1b
 389 001a 00C0      		rjmp .
 390 001c 0000      		nop
 391               	.LVL36:
 392               	.L24:
 393               		.loc 3 187 2 is_stmt 0 view .LVU86
 394               	.LBE23:
 395               	.LBE22:
 878:tmk_core/common/action.c ****     } else {
 879:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 880:tmk_core/common/action.c ****     }
 881:tmk_core/common/action.c ****     unregister_code(code);
 396               		.loc 1 881 5 is_stmt 1 view .LVU87
 397 001e 8C2F      		mov r24,r28
 398               	/* epilogue start */
 882:tmk_core/common/action.c **** }
 399               		.loc 1 882 1 is_stmt 0 view .LVU88
 400 0020 CF91      		pop r28
 401               	.LVL37:
 881:tmk_core/common/action.c **** }
 402               		.loc 1 881 5 view .LVU89
 403 0022 0C94 0000 		jmp unregister_code
 404               	.LVL38:
 881:tmk_core/common/action.c **** }
 405               		.loc 1 881 5 view .LVU90
 406               		.cfi_endproc
 407               	.LFE116:
 409               		.section	.text.register_mods,"ax",@progbits
 410               	.global	register_mods
 412               	register_mods:
 413               	.LVL39:
 414               	.LFB117:
 883:tmk_core/common/action.c **** 
 884:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 885:tmk_core/common/action.c ****  *
 886:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 887:tmk_core/common/action.c ****  */
 888:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 415               		.loc 1 888 34 is_stmt 1 view -0
 416               		.cfi_startproc
 417               	/* prologue: function */
 418               	/* frame size = 0 */
 419               	/* stack size = 0 */
 420               	.L__stack_usage = 0
 889:tmk_core/common/action.c ****     if (mods) {
 421               		.loc 1 889 5 view .LVU92
 422               		.loc 1 889 8 is_stmt 0 view .LVU93
 423 0000 8823      		tst r24
 424 0002 01F0      		breq .L25
 890:tmk_core/common/action.c ****         add_mods(mods);
 425               		.loc 1 890 9 is_stmt 1 view .LVU94
 426 0004 0E94 0000 		call add_mods
 427               	.LVL40:
 891:tmk_core/common/action.c ****         send_keyboard_report();
 428               		.loc 1 891 9 view .LVU95
 429 0008 0C94 0000 		jmp send_keyboard_report
 430               	.LVL41:
 431               	.L25:
 432               	/* epilogue start */
 892:tmk_core/common/action.c ****     }
 893:tmk_core/common/action.c **** }
 433               		.loc 1 893 1 is_stmt 0 view .LVU96
 434 000c 0895      		ret
 435               		.cfi_endproc
 436               	.LFE117:
 438               		.section	.text.unregister_mods,"ax",@progbits
 439               	.global	unregister_mods
 441               	unregister_mods:
 442               	.LVL42:
 443               	.LFB118:
 894:tmk_core/common/action.c **** 
 895:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 896:tmk_core/common/action.c ****  *
 897:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 898:tmk_core/common/action.c ****  */
 899:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 444               		.loc 1 899 36 is_stmt 1 view -0
 445               		.cfi_startproc
 446               	/* prologue: function */
 447               	/* frame size = 0 */
 448               	/* stack size = 0 */
 449               	.L__stack_usage = 0
 900:tmk_core/common/action.c ****     if (mods) {
 450               		.loc 1 900 5 view .LVU98
 451               		.loc 1 900 8 is_stmt 0 view .LVU99
 452 0000 8823      		tst r24
 453 0002 01F0      		breq .L27
 901:tmk_core/common/action.c ****         del_mods(mods);
 454               		.loc 1 901 9 is_stmt 1 view .LVU100
 455 0004 0E94 0000 		call del_mods
 456               	.LVL43:
 902:tmk_core/common/action.c ****         send_keyboard_report();
 457               		.loc 1 902 9 view .LVU101
 458 0008 0C94 0000 		jmp send_keyboard_report
 459               	.LVL44:
 460               	.L27:
 461               	/* epilogue start */
 903:tmk_core/common/action.c ****     }
 904:tmk_core/common/action.c **** }
 462               		.loc 1 904 1 is_stmt 0 view .LVU102
 463 000c 0895      		ret
 464               		.cfi_endproc
 465               	.LFE118:
 467               		.section	.text.process_action,"ax",@progbits
 468               	.global	process_action
 470               	process_action:
 471               	.LVL45:
 472               	.LFB113:
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 473               		.loc 1 206 59 is_stmt 1 view -0
 474               		.cfi_startproc
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 475               		.loc 1 206 59 is_stmt 0 view .LVU104
 476 0000 BF92      		push r11
 477               	.LCFI5:
 478               		.cfi_def_cfa_offset 3
 479               		.cfi_offset 11, -2
 480 0002 CF92      		push r12
 481               	.LCFI6:
 482               		.cfi_def_cfa_offset 4
 483               		.cfi_offset 12, -3
 484 0004 DF92      		push r13
 485               	.LCFI7:
 486               		.cfi_def_cfa_offset 5
 487               		.cfi_offset 13, -4
 488 0006 EF92      		push r14
 489               	.LCFI8:
 490               		.cfi_def_cfa_offset 6
 491               		.cfi_offset 14, -5
 492 0008 FF92      		push r15
 493               	.LCFI9:
 494               		.cfi_def_cfa_offset 7
 495               		.cfi_offset 15, -6
 496 000a 0F93      		push r16
 497               	.LCFI10:
 498               		.cfi_def_cfa_offset 8
 499               		.cfi_offset 16, -7
 500 000c 1F93      		push r17
 501               	.LCFI11:
 502               		.cfi_def_cfa_offset 9
 503               		.cfi_offset 17, -8
 504 000e CF93      		push r28
 505               	.LCFI12:
 506               		.cfi_def_cfa_offset 10
 507               		.cfi_offset 28, -9
 508 0010 DF93      		push r29
 509               	.LCFI13:
 510               		.cfi_def_cfa_offset 11
 511               		.cfi_offset 29, -10
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 9 */
 515               	.L__stack_usage = 9
 516 0012 6C01      		movw r12,r24
 517 0014 D62F      		mov r29,r22
 206:tmk_core/common/action.c ****     keyevent_t event = record->event;
 518               		.loc 1 206 59 view .LVU105
 519 0016 C72F      		mov r28,r23
 207:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 520               		.loc 1 207 5 is_stmt 1 view .LVU106
 521               	.LVL46:
 209:tmk_core/common/action.c **** #endif
 522               		.loc 1 209 5 view .LVU107
 209:tmk_core/common/action.c **** #endif
 523               		.loc 1 209 36 is_stmt 0 view .LVU108
 524 0018 FC01      		movw r30,r24
 525 001a 1581      		ldd r17,Z+5
 526 001c 1295      		swap r17
 527 001e 1F70      		andi r17,lo8(15)
 528               	.LVL47:
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 529               		.loc 1 212 5 is_stmt 1 view .LVU109
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 530               		.loc 1 212 14 is_stmt 0 view .LVU110
 531 0020 0281      		ldd r16,Z+2
 212:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 532               		.loc 1 212 8 view .LVU111
 533 0022 0111      		cpse r16,__zero_reg__
 214:tmk_core/common/action.c ****     }
 534               		.loc 1 214 9 is_stmt 1 view .LVU112
 535 0024 0E94 0000 		call clear_weak_mods
 536               	.LVL48:
 537               	.L30:
 218:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 538               		.loc 1 218 5 view .LVU113
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 539               		.loc 1 220 5 view .LVU114
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 540               		.loc 1 220 9 is_stmt 0 view .LVU115
 541 0028 0E94 0000 		call is_oneshot_layer_active
 542               	.LVL49:
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 543               		.loc 1 220 9 view .LVU116
 544 002c E82E      		mov r14,r24
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 545               		.loc 1 220 8 view .LVU117
 546 002e 8823      		tst r24
 547 0030 01F0      		breq .L31
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 548               		.loc 1 220 35 discriminator 1 view .LVU118
 549 0032 0023      		tst r16
 550 0034 01F0      		breq .L101
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 551               		.loc 1 220 55 discriminator 2 view .LVU119
 552 0036 80E2      		ldi r24,lo8(32)
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 553               		.loc 1 220 55 discriminator 2 view .LVU120
 554 0038 8D0F      		add r24,r29
 220:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555               		.loc 1 220 52 discriminator 2 view .LVU121
 556 003a 8830      		cpi r24,lo8(8)
 557 003c 00F0      		brlo .L101
 221:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 558               		.loc 1 221 9 is_stmt 1 view .LVU122
 559 003e 82E0      		ldi r24,lo8(2)
 560 0040 0E94 0000 		call clear_oneshot_layer_state
 561               	.LVL50:
 222:tmk_core/common/action.c ****     }
 562               		.loc 1 222 9 view .LVU123
 222:tmk_core/common/action.c ****     }
 563               		.loc 1 222 31 is_stmt 0 view .LVU124
 564 0044 0E94 0000 		call is_oneshot_layer_active
 565               	.LVL51:
 222:tmk_core/common/action.c ****     }
 566               		.loc 1 222 9 view .LVU125
 567 0048 91E0      		ldi r25,lo8(1)
 568 004a E82E      		mov r14,r24
 569 004c E926      		eor r14,r25
 570               	.LVL52:
 571               	.L31:
 226:tmk_core/common/action.c ****         /* Key and Mods */
 572               		.loc 1 226 5 is_stmt 1 view .LVU126
 226:tmk_core/common/action.c ****         /* Key and Mods */
 573               		.loc 1 226 24 is_stmt 0 view .LVU127
 574 004e BC2E      		mov r11,r28
 575 0050 B294      		swap r11
 576 0052 9FE0      		ldi r25,lo8(15)
 577 0054 B922      		and r11,r25
 226:tmk_core/common/action.c ****         /* Key and Mods */
 578               		.loc 1 226 5 view .LVU128
 579 0056 EB2D      		mov r30,r11
 580 0058 F0E0      		ldi r31,0
 581 005a E050      		subi r30,lo8(-(gs(.L34)))
 582 005c F040      		sbci r31,hi8(-(gs(.L34)))
 583 005e 0C94 0000 		jmp __tablejump2__
 584               		.section	.jumptables.gcc.process_action,"a",@progbits
 585               		.p2align	1
 586               	.L34:
 587 0000 0000      		.word gs(.L40)
 588 0002 0000      		.word gs(.L40)
 589 0004 0000      		.word gs(.L39)
 590 0006 0000      		.word gs(.L39)
 591 0008 0000      		.word gs(.L32)
 592 000a 0000      		.word gs(.L32)
 593 000c 0000      		.word gs(.L32)
 594 000e 0000      		.word gs(.L32)
 595 0010 0000      		.word gs(.L38)
 596 0012 0000      		.word gs(.L37)
 597 0014 0000      		.word gs(.L36)
 598 0016 0000      		.word gs(.L36)
 599 0018 0000      		.word gs(.L35)
 600 001a 0000      		.word gs(.L32)
 601 001c 0000      		.word gs(.L32)
 602 001e 0000      		.word gs(.L33)
 603               		.section	.text.process_action
 604               	.LVL53:
 605               	.L101:
 218:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 606               		.loc 1 218 10 view .LVU129
 607 0062 E12C      		mov r14,__zero_reg__
 608 0064 00C0      		rjmp .L31
 609               	.LVL54:
 610               	.L40:
 611               	.LBB24:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 612               		.loc 1 230 13 is_stmt 1 view .LVU130
 613 0066 1C2F      		mov r17,r28
 614               	.LVL55:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 615               		.loc 1 230 13 is_stmt 0 view .LVU131
 616 0068 1F70      		andi r17,lo8(15)
 230:tmk_core/common/action.c ****             if (event.pressed) {
 617               		.loc 1 230 44 view .LVU132
 618 006a C07F      		andi r28,lo8(-16)
 619               	.LVL56:
 230:tmk_core/common/action.c ****             if (event.pressed) {
 620               		.loc 1 230 21 view .LVU133
 621 006c 01F0      		breq .L41
 230:tmk_core/common/action.c ****             if (event.pressed) {
 622               		.loc 1 230 21 discriminator 2 view .LVU134
 623 006e 1295      		swap r17
 624 0070 107F      		andi r17,lo8(-16)
 625               	.L41:
 626               	.LVL57:
 231:tmk_core/common/action.c ****                 if (mods) {
 627               		.loc 1 231 13 is_stmt 1 discriminator 4 view .LVU135
 231:tmk_core/common/action.c ****                 if (mods) {
 628               		.loc 1 231 16 is_stmt 0 discriminator 4 view .LVU136
 629 0072 0023      		tst r16
 630 0074 01F0      		breq .L42
 232:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 631               		.loc 1 232 17 is_stmt 1 view .LVU137
 232:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 632               		.loc 1 232 20 is_stmt 0 view .LVU138
 633 0076 1123      		tst r17
 634 0078 01F0      		breq .L129
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 635               		.loc 1 233 21 is_stmt 1 view .LVU139
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 636               		.loc 1 233 25 is_stmt 0 view .LVU140
 637 007a 80E2      		ldi r24,lo8(32)
 638 007c 8D0F      		add r24,r29
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 639               		.loc 1 233 24 view .LVU141
 640 007e 8830      		cpi r24,lo8(8)
 641 0080 00F0      		brlo .L44
 233:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 642               		.loc 1 233 49 discriminator 1 view .LVU142
 643 0082 D111      		cpse r29,__zero_reg__
 644 0084 00C0      		rjmp .L45
 645               	.L44:
 237:tmk_core/common/action.c ****                     } else {
 646               		.loc 1 237 25 is_stmt 1 view .LVU143
 647 0086 812F      		mov r24,r17
 648 0088 0E94 0000 		call add_mods
 649               	.LVL58:
 650               	.L46:
 241:tmk_core/common/action.c ****                 }
 651               		.loc 1 241 21 view .LVU144
 652 008c 0E94 0000 		call send_keyboard_report
 653               	.LVL59:
 243:tmk_core/common/action.c ****             } else {
 654               		.loc 1 243 17 view .LVU145
 655               	.L129:
 243:tmk_core/common/action.c ****             } else {
 656               		.loc 1 243 17 is_stmt 0 view .LVU146
 657               	.LBE24:
 534:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 658               		.loc 1 534 75 is_stmt 1 view .LVU147
 535:tmk_core/common/action.c ****                         } else {
 659               		.loc 1 535 29 view .LVU148
 660 0090 8D2F      		mov r24,r29
 661 0092 0E94 0000 		call register_code
 662               	.LVL60:
 663 0096 00C0      		rjmp .L32
 664               	.LVL61:
 665               	.L45:
 666               	.LBB25:
 239:tmk_core/common/action.c ****                     }
 667               		.loc 1 239 25 view .LVU149
 668 0098 812F      		mov r24,r17
 669 009a 0E94 0000 		call add_weak_mods
 670               	.LVL62:
 671 009e 00C0      		rjmp .L46
 672               	.L42:
 245:tmk_core/common/action.c ****                 if (mods) {
 673               		.loc 1 245 17 view .LVU150
 674 00a0 8D2F      		mov r24,r29
 675 00a2 0E94 0000 		call unregister_code
 676               	.LVL63:
 246:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 677               		.loc 1 246 17 view .LVU151
 246:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 678               		.loc 1 246 20 is_stmt 0 view .LVU152
 679 00a6 1123      		tst r17
 680 00a8 01F0      		breq .L32
 247:tmk_core/common/action.c ****                         del_mods(mods);
 681               		.loc 1 247 21 is_stmt 1 view .LVU153
 247:tmk_core/common/action.c ****                         del_mods(mods);
 682               		.loc 1 247 25 is_stmt 0 view .LVU154
 683 00aa 80E2      		ldi r24,lo8(32)
 684 00ac 8D0F      		add r24,r29
 247:tmk_core/common/action.c ****                         del_mods(mods);
 685               		.loc 1 247 24 view .LVU155
 686 00ae 8830      		cpi r24,lo8(8)
 687 00b0 00F0      		brlo .L48
 247:tmk_core/common/action.c ****                         del_mods(mods);
 688               		.loc 1 247 49 discriminator 1 view .LVU156
 689 00b2 D111      		cpse r29,__zero_reg__
 690 00b4 00C0      		rjmp .L49
 691               	.L48:
 248:tmk_core/common/action.c ****                     } else {
 692               		.loc 1 248 25 is_stmt 1 view .LVU157
 693 00b6 812F      		mov r24,r17
 694 00b8 0E94 0000 		call del_mods
 695               	.LVL64:
 696               	.L50:
 252:tmk_core/common/action.c ****                 }
 697               		.loc 1 252 21 view .LVU158
 698 00bc 0E94 0000 		call send_keyboard_report
 699               	.LVL65:
 700               	.L32:
 252:tmk_core/common/action.c ****                 }
 701               		.loc 1 252 21 is_stmt 0 view .LVU159
 702               	.LBE25:
 667:tmk_core/common/action.c ****         case ACT_LAYER:
 703               		.loc 1 667 5 is_stmt 1 view .LVU160
 704 00c0 2B2D      		mov r18,r11
 705 00c2 2850      		subi r18,8
 706 00c4 330B      		sbc r19,r19
 707 00c6 2430      		cpi r18,4
 708 00c8 3105      		cpc r19,__zero_reg__
 709 00ca 00F4      		brsh .L96
 674:tmk_core/common/action.c ****             break;
 710               		.loc 1 674 13 view .LVU161
 711 00cc 0E94 0000 		call host_keyboard_leds
 712               	.LVL66:
 713 00d0 0E94 0000 		call led_set
 714               	.LVL67:
 675:tmk_core/common/action.c ****         default:
 715               		.loc 1 675 13 view .LVU162
 716               	.L96:
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 717               		.loc 1 709 5 view .LVU163
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 718               		.loc 1 709 8 is_stmt 0 view .LVU164
 719 00d4 EE20      		tst r14
 720 00d6 01F4      		brne .+2
 721 00d8 00C0      		rjmp .L29
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 722               		.loc 1 709 33 discriminator 1 view .LVU165
 723 00da 0E94 0000 		call get_oneshot_layer_state
 724               	.LVL68:
 709:tmk_core/common/action.c ****         record->event.pressed = false;
 725               		.loc 1 709 28 discriminator 1 view .LVU166
 726 00de 80FD      		sbrc r24,0
 727 00e0 00C0      		rjmp .L29
 710:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 728               		.loc 1 710 9 is_stmt 1 view .LVU167
 710:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 729               		.loc 1 710 31 is_stmt 0 view .LVU168
 730 00e2 F601      		movw r30,r12
 731 00e4 1282      		std Z+2,__zero_reg__
 711:tmk_core/common/action.c ****         process_record(record);
 732               		.loc 1 711 9 is_stmt 1 view .LVU169
 733 00e6 0E94 0000 		call get_oneshot_layer
 734               	.LVL69:
 735 00ea 0E94 0000 		call layer_on
 736               	.LVL70:
 712:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 737               		.loc 1 712 9 view .LVU170
 738 00ee C601      		movw r24,r12
 739 00f0 0E94 0000 		call process_record
 740               	.LVL71:
 713:tmk_core/common/action.c ****     }
 741               		.loc 1 713 9 view .LVU171
 742 00f4 0E94 0000 		call get_oneshot_layer
 743               	.LVL72:
 744               	/* epilogue start */
 716:tmk_core/common/action.c **** 
 745               		.loc 1 716 1 is_stmt 0 view .LVU172
 746 00f8 DF91      		pop r29
 747               	.LVL73:
 716:tmk_core/common/action.c **** 
 748               		.loc 1 716 1 view .LVU173
 749 00fa CF91      		pop r28
 716:tmk_core/common/action.c **** 
 750               		.loc 1 716 1 view .LVU174
 751 00fc 1F91      		pop r17
 752 00fe 0F91      		pop r16
 753 0100 FF90      		pop r15
 754 0102 EF90      		pop r14
 755               	.LVL74:
 716:tmk_core/common/action.c **** 
 756               		.loc 1 716 1 view .LVU175
 757 0104 DF90      		pop r13
 758 0106 CF90      		pop r12
 759               	.LVL75:
 716:tmk_core/common/action.c **** 
 760               		.loc 1 716 1 view .LVU176
 761 0108 BF90      		pop r11
 713:tmk_core/common/action.c ****     }
 762               		.loc 1 713 9 view .LVU177
 763 010a 0C94 0000 		jmp layer_off
 764               	.LVL76:
 765               	.L49:
 766               	.LBB26:
 250:tmk_core/common/action.c ****                     }
 767               		.loc 1 250 25 is_stmt 1 view .LVU178
 768 010e 812F      		mov r24,r17
 769 0110 0E94 0000 		call del_weak_mods
 770               	.LVL77:
 771 0114 00C0      		rjmp .L50
 772               	.LVL78:
 773               	.L39:
 250:tmk_core/common/action.c ****                     }
 774               		.loc 1 250 25 is_stmt 0 view .LVU179
 775               	.LBE26:
 776               	.LBB27:
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 777               		.loc 1 259 13 is_stmt 1 view .LVU180
 778 0116 FC2F      		mov r31,r28
 779 0118 FF70      		andi r31,lo8(15)
 780 011a FF2E      		mov r15,r31
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 781               		.loc 1 259 44 is_stmt 0 view .LVU181
 782 011c C07F      		andi r28,lo8(-16)
 783               	.LVL79:
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 784               		.loc 1 259 21 view .LVU182
 785 011e C032      		cpi r28,lo8(32)
 786 0120 01F0      		breq .L51
 259:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 787               		.loc 1 259 21 discriminator 2 view .LVU183
 788 0122 F294      		swap r15
 789 0124 80EF      		ldi r24,lo8(-16)
 790 0126 F822      		and r15,r24
 791               	.L51:
 792               	.LVL80:
 260:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 793               		.loc 1 260 13 is_stmt 1 discriminator 4 view .LVU184
 794 0128 DD23      		tst r29
 795 012a 01F0      		breq .L52
 796 012c D130      		cpi r29,lo8(1)
 797 012e 01F0      		breq .L53
 315:tmk_core/common/action.c ****                         if (tap_count > 0) {
 798               		.loc 1 315 21 view .LVU185
 315:tmk_core/common/action.c ****                         if (tap_count > 0) {
 799               		.loc 1 315 24 is_stmt 0 view .LVU186
 800 0130 0023      		tst r16
 801 0132 01F0      		breq .L61
 316:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 802               		.loc 1 316 25 is_stmt 1 view .LVU187
 316:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 803               		.loc 1 316 28 is_stmt 0 view .LVU188
 804 0134 1123      		tst r17
 805 0136 01F0      		breq .L62
 318:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 806               		.loc 1 318 29 is_stmt 1 view .LVU189
 322:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 807               		.loc 1 322 33 is_stmt 0 view .LVU190
 808 0138 F601      		movw r30,r12
 809 013a 8581      		ldd r24,Z+5
 318:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 810               		.loc 1 318 32 view .LVU191
 811 013c 80FF      		sbrs r24,0
 812 013e 00C0      		rjmp .L129
 323:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 813               		.loc 1 323 76 is_stmt 1 view .LVU192
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 814               		.loc 1 325 33 view .LVU193
 325:tmk_core/common/action.c ****                                 register_mods(mods);
 815               		.loc 1 325 51 is_stmt 0 view .LVU194
 816 0140 8F70      		andi r24,lo8(15)
 817 0142 8583      		std Z+5,r24
 326:tmk_core/common/action.c ****                             } else
 818               		.loc 1 326 33 is_stmt 1 view .LVU195
 819 0144 00C0      		rjmp .L62
 820               	.L52:
 264:tmk_core/common/action.c ****                         if (tap_count == 0) {
 821               		.loc 1 264 21 view .LVU196
 264:tmk_core/common/action.c ****                         if (tap_count == 0) {
 822               		.loc 1 264 24 is_stmt 0 view .LVU197
 823 0146 0023      		tst r16
 824 0148 01F0      		breq .L55
 265:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 825               		.loc 1 265 25 is_stmt 1 view .LVU198
 265:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 826               		.loc 1 265 28 is_stmt 0 view .LVU199
 827 014a 1111      		cpse r17,__zero_reg__
 828 014c 00C0      		rjmp .L56
 829               	.L57:
 279:tmk_core/common/action.c ****                         }
 830               		.loc 1 279 29 is_stmt 1 view .LVU200
 279:tmk_core/common/action.c ****                         }
 831               		.loc 1 279 50 is_stmt 0 view .LVU201
 832 014e 0E94 0000 		call get_oneshot_mods
 833               	.LVL81:
 279:tmk_core/common/action.c ****                         }
 834               		.loc 1 279 29 view .LVU202
 835 0152 8F29      		or r24,r15
 836               	.LVL82:
 837               	.L128:
 279:tmk_core/common/action.c ****                         }
 838               		.loc 1 279 29 view .LVU203
 839               	.LBE27:
 461:tmk_core/common/action.c ****             } else {
 840               		.loc 1 461 17 view .LVU204
 841 0154 0E94 0000 		call register_mods
 842               	.LVL83:
 843 0158 00C0      		rjmp .L32
 844               	.LVL84:
 845               	.L56:
 846               	.LBB30:
 268:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 847               		.loc 1 268 32 is_stmt 1 view .LVU205
 268:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 848               		.loc 1 268 35 is_stmt 0 view .LVU206
 849 015a 1130      		cpi r17,lo8(1)
 850 015c 01F4      		brne .L57
 269:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 851               		.loc 1 269 65 is_stmt 1 view .LVU207
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 852               		.loc 1 270 29 view .LVU208
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 853               		.loc 1 270 53 is_stmt 0 view .LVU209
 854 015e 0E94 0000 		call get_oneshot_mods
 855               	.LVL85:
 270:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 856               		.loc 1 270 29 view .LVU210
 857 0162 8F29      		or r24,r15
 858 0164 0E94 0000 		call set_oneshot_mods
 859               	.LVL86:
 860 0168 00C0      		rjmp .L32
 861               	.L55:
 282:tmk_core/common/action.c ****                             clear_oneshot_mods();
 862               		.loc 1 282 25 is_stmt 1 view .LVU211
 282:tmk_core/common/action.c ****                             clear_oneshot_mods();
 863               		.loc 1 282 28 is_stmt 0 view .LVU212
 864 016a 1111      		cpse r17,__zero_reg__
 865 016c 00C0      		rjmp .L58
 866               	.L130:
 297:tmk_core/common/action.c ****                             unregister_mods(mods);
 867               		.loc 1 297 29 is_stmt 1 view .LVU213
 868 016e 0E94 0000 		call clear_oneshot_mods
 869               	.LVL87:
 298:tmk_core/common/action.c ****                         }
 870               		.loc 1 298 29 view .LVU214
 871               	.L64:
 345:tmk_core/common/action.c ****                             unregister_mods(mods);
 872               		.loc 1 345 67 view .LVU215
 346:tmk_core/common/action.c ****                         }
 873               		.loc 1 346 29 view .LVU216
 874 0172 8F2D      		mov r24,r15
 875 0174 0E94 0000 		call unregister_mods
 876               	.LVL88:
 877 0178 00C0      		rjmp .L32
 878               	.L58:
 285:tmk_core/common/action.c ****                             // Retain Oneshot mods
 879               		.loc 1 285 32 view .LVU217
 285:tmk_core/common/action.c ****                             // Retain Oneshot mods
 880               		.loc 1 285 35 is_stmt 0 view .LVU218
 881 017a 1130      		cpi r17,lo8(1)
 882 017c 01F4      		brne .+2
 883 017e 00C0      		rjmp .L32
 884 0180 00C0      		rjmp .L130
 885               	.L53:
 304:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 886               		.loc 1 304 21 is_stmt 1 view .LVU219
 304:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 887               		.loc 1 304 24 is_stmt 0 view .LVU220
 888 0182 0023      		tst r16
 889 0184 01F0      		breq .L60
 305:tmk_core/common/action.c ****                             register_mods(mods);
 890               		.loc 1 305 25 is_stmt 1 view .LVU221
 305:tmk_core/common/action.c ****                             register_mods(mods);
 891               		.loc 1 305 28 is_stmt 0 view .LVU222
 892 0186 1630      		cpi r17,lo8(6)
 893 0188 00F0      		brlo .+2
 894 018a 00C0      		rjmp .L32
 895               	.L62:
 334:tmk_core/common/action.c ****                             register_mods(mods);
 896               		.loc 1 334 67 is_stmt 1 view .LVU223
 335:tmk_core/common/action.c ****                         }
 897               		.loc 1 335 29 view .LVU224
 898 018c 8F2D      		mov r24,r15
 899 018e 00C0      		rjmp .L128
 900               	.L60:
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 901               		.loc 1 309 25 view .LVU225
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 902               		.loc 1 309 28 is_stmt 0 view .LVU226
 903 0190 1530      		cpi r17,lo8(5)
 904 0192 00F0      		brlo .+2
 905 0194 00C0      		rjmp .L32
 906 0196 00C0      		rjmp .L64
 907               	.L61:
 338:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 908               		.loc 1 338 25 is_stmt 1 view .LVU227
 338:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 909               		.loc 1 338 28 is_stmt 0 view .LVU228
 910 0198 1123      		tst r17
 911 019a 01F0      		breq .L64
 339:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 912               		.loc 1 339 71 is_stmt 1 view .LVU229
 340:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 913               		.loc 1 340 29 view .LVU230
 340:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 914               		.loc 1 340 32 is_stmt 0 view .LVU231
 915 019c D933      		cpi r29,lo8(57)
 916 019e 01F4      		brne .L95
 341:tmk_core/common/action.c ****                             }
 917               		.loc 1 341 33 is_stmt 1 view .LVU232
 918               	.LVL89:
 919               	.LBB28:
 920               	.LBI28:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 921               		.loc 3 166 1 view .LVU233
 922               	.LBB29:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 923               		.loc 3 168 2 view .LVU234
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 924               		.loc 3 172 2 view .LVU235
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 925               		.loc 3 173 2 view .LVU236
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 926               		.loc 3 174 2 view .LVU237
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 927               		.loc 3 184 3 view .LVU238
 928               		.loc 3 187 2 view .LVU239
 929 01a0 FFEF      		ldi r31,lo8(255999)
 930 01a2 27EE      		ldi r18,hi8(255999)
 931 01a4 33E0      		ldi r19,hlo8(255999)
 932 01a6 F150      	1:	subi r31,1
 933 01a8 2040      		sbci r18,0
 934 01aa 3040      		sbci r19,0
 935 01ac 01F4      		brne 1b
 936               	.LVL90:
 937               	.L131:
 938               		.loc 3 187 2 is_stmt 0 view .LVU240
 939               	.LBE29:
 940               	.LBE28:
 941               	.LBE30:
 942               	.LBB31:
 943               	.LBB32:
 944 01ae 00C0      		rjmp .
 945 01b0 0000      		nop
 946               	.L95:
 947               	.LBE32:
 948               	.LBE31:
 548:tmk_core/common/action.c ****                         } else {
 949               		.loc 1 548 29 is_stmt 1 view .LVU241
 950 01b2 8D2F      		mov r24,r29
 951 01b4 0E94 0000 		call unregister_code
 952               	.LVL91:
 953 01b8 00C0      		rjmp .L32
 954               	.L38:
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 955               		.loc 1 414 13 view .LVU242
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 956               		.loc 1 414 39 is_stmt 0 view .LVU243
 957 01ba 8C2F      		mov r24,r28
 958 01bc 8370      		andi r24,lo8(3)
 414:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 959               		.loc 1 414 16 view .LVU244
 960 01be 01F0      		breq .+2
 961 01c0 00C0      		rjmp .L66
 416:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 962               		.loc 1 416 17 is_stmt 1 view .LVU245
 416:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 963               		.loc 1 416 20 is_stmt 0 view .LVU246
 964 01c2 0111      		cpse r16,__zero_reg__
 965 01c4 00C0      		rjmp .L32
 966               	.LBB34:
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 967               		.loc 1 417 21 is_stmt 1 view .LVU247
 968               	.LVL92:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 969               		.loc 1 418 21 view .LVU248
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 970               		.loc 1 417 61 is_stmt 0 view .LVU249
 971 01c6 4D2F      		mov r20,r29
 972 01c8 4295      		swap r20
 973 01ca 4695      		lsr r20
 974 01cc 4770      		andi r20,lo8(7)
 417:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 975               		.loc 1 417 35 view .LVU250
 976 01ce 440F      		lsl r20
 977 01d0 440F      		lsl r20
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 978               		.loc 1 418 77 view .LVU251
 979 01d2 0D2F      		mov r16,r29
 980               	.LVL93:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 981               		.loc 1 418 77 view .LVU252
 982 01d4 0F70      		andi r16,lo8(15)
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 983               		.loc 1 418 44 view .LVU253
 984 01d6 10E0      		ldi r17,0
 985               	.LVL94:
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 986               		.loc 1 418 44 view .LVU254
 987 01d8 30E0      		ldi r19,0
 988 01da 20E0      		ldi r18,0
 418:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 989               		.loc 1 418 35 view .LVU255
 990 01dc 042E      		mov r0,r20
 991 01de 00C0      		rjmp 2f
 992               		1:
 993 01e0 000F      		lsl r16
 994 01e2 111F      		rol r17
 995 01e4 221F      		rol r18
 996 01e6 331F      		rol r19
 997               		2:
 998 01e8 0A94      		dec r0
 999 01ea 02F4      		brpl 1b
 1000               	.LVL95:
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1001               		.loc 1 419 21 is_stmt 1 view .LVU256
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1002               		.loc 1 419 104 is_stmt 0 view .LVU257
 1003 01ec 60E0      		ldi r22,0
 1004 01ee 70E0      		ldi r23,0
 1005 01f0 CB01      		movw r24,r22
 1006 01f2 D4FF      		sbrs r29,4
 1007 01f4 00C0      		rjmp .L67
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1008               		.loc 1 419 94 discriminator 1 view .LVU258
 1009 01f6 6FE0      		ldi r22,lo8(15)
 1010 01f8 70E0      		ldi r23,0
 1011 01fa 80E0      		ldi r24,0
 1012 01fc 90E0      		ldi r25,0
 1013 01fe 00C0      		rjmp 2f
 1014               		1:
 1015 0200 660F      		lsl r22
 1016 0202 771F      		rol r23
 1017 0204 881F      		rol r24
 1018 0206 991F      		rol r25
 1019               		2:
 1020 0208 4A95      		dec r20
 1021 020a 02F4      		brpl 1b
 419:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1022               		.loc 1 419 104 discriminator 1 view .LVU259
 1023 020c 6095      		com r22
 1024 020e 7095      		com r23
 1025 0210 8095      		com r24
 1026 0212 9095      		com r25
 1027               	.L67:
 1028               	.LVL96:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1029               		.loc 1 420 21 is_stmt 1 discriminator 4 view .LVU260
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1030               		.loc 1 420 47 is_stmt 0 discriminator 4 view .LVU261
 1031 0214 C695      		lsr r28
 1032 0216 C695      		lsr r28
 1033               	.LVL97:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1034               		.loc 1 420 47 discriminator 4 view .LVU262
 1035 0218 C370      		andi r28,lo8(3)
 1036 021a 602B      		or r22,r16
 1037               	.LVL98:
 420:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1038               		.loc 1 420 47 discriminator 4 view .LVU263
 1039 021c 712B      		or r23,r17
 1040 021e 822B      		or r24,r18
 1041 0220 932B      		or r25,r19
 1042 0222 C230      		cpi r28,lo8(2)
 1043 0224 01F0      		breq .L68
 1044 0226 00F4      		brsh .L69
 1045 0228 C130      		cpi r28,lo8(1)
 1046 022a 01F0      		breq .L70
 422:tmk_core/common/action.c ****                             break;
 1047               		.loc 1 422 29 is_stmt 1 view .LVU264
 1048 022c 0E94 0000 		call default_layer_and
 1049               	.LVL99:
 423:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1050               		.loc 1 423 29 view .LVU265
 1051 0230 00C0      		rjmp .L32
 1052               	.L70:
 425:tmk_core/common/action.c ****                             break;
 1053               		.loc 1 425 29 view .LVU266
 1054 0232 0E94 0000 		call default_layer_or
 1055               	.LVL100:
 426:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1056               		.loc 1 426 29 view .LVU267
 1057 0236 00C0      		rjmp .L32
 1058               	.L68:
 428:tmk_core/common/action.c ****                             break;
 1059               		.loc 1 428 29 view .LVU268
 1060 0238 0E94 0000 		call default_layer_xor
 1061               	.LVL101:
 429:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1062               		.loc 1 429 29 view .LVU269
 1063 023c 00C0      		rjmp .L32
 1064               	.L69:
 431:tmk_core/common/action.c ****                             break;
 1065               		.loc 1 431 29 view .LVU270
 1066 023e 0E94 0000 		call default_layer_set
 1067               	.LVL102:
 432:tmk_core/common/action.c ****                     }
 1068               		.loc 1 432 29 view .LVU271
 1069 0242 00C0      		rjmp .L32
 1070               	.LVL103:
 1071               	.L66:
 432:tmk_core/common/action.c ****                     }
 1072               		.loc 1 432 29 is_stmt 0 view .LVU272
 1073               	.LBE34:
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1074               		.loc 1 437 17 is_stmt 1 view .LVU273
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1075               		.loc 1 437 21 is_stmt 0 view .LVU274
 1076 0244 8695      		lsr r24
 1077 0246 0023      		tst r16
 1078 0248 01F0      		breq .L72
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1079               		.loc 1 437 21 discriminator 1 view .LVU275
 1080 024a 8C2F      		mov r24,r28
 1081 024c 8170      		andi r24,lo8(1)
 1082               	.L72:
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1083               		.loc 1 437 20 discriminator 4 view .LVU276
 1084 024e 8823      		tst r24
 1085 0250 01F4      		brne .+2
 1086 0252 00C0      		rjmp .L32
 1087               	.LBB35:
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1088               		.loc 1 438 21 is_stmt 1 view .LVU277
 1089               	.LVL104:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1090               		.loc 1 439 21 view .LVU278
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1091               		.loc 1 438 61 is_stmt 0 view .LVU279
 1092 0254 4D2F      		mov r20,r29
 1093 0256 4295      		swap r20
 1094 0258 4695      		lsr r20
 1095 025a 4770      		andi r20,lo8(7)
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1096               		.loc 1 438 35 view .LVU280
 1097 025c 440F      		lsl r20
 1098 025e 440F      		lsl r20
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1099               		.loc 1 439 77 view .LVU281
 1100 0260 0D2F      		mov r16,r29
 1101               	.LVL105:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1102               		.loc 1 439 77 view .LVU282
 1103 0262 0F70      		andi r16,lo8(15)
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1104               		.loc 1 439 44 view .LVU283
 1105 0264 10E0      		ldi r17,0
 1106               	.LVL106:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1107               		.loc 1 439 44 view .LVU284
 1108 0266 30E0      		ldi r19,0
 1109 0268 20E0      		ldi r18,0
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1110               		.loc 1 439 35 view .LVU285
 1111 026a 042E      		mov r0,r20
 1112 026c 00C0      		rjmp 2f
 1113               		1:
 1114 026e 000F      		lsl r16
 1115 0270 111F      		rol r17
 1116 0272 221F      		rol r18
 1117 0274 331F      		rol r19
 1118               		2:
 1119 0276 0A94      		dec r0
 1120 0278 02F4      		brpl 1b
 1121               	.LVL107:
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1122               		.loc 1 440 21 is_stmt 1 view .LVU286
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1123               		.loc 1 440 104 is_stmt 0 view .LVU287
 1124 027a 60E0      		ldi r22,0
 1125 027c 70E0      		ldi r23,0
 1126 027e CB01      		movw r24,r22
 1127 0280 D4FF      		sbrs r29,4
 1128 0282 00C0      		rjmp .L73
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1129               		.loc 1 440 94 discriminator 1 view .LVU288
 1130 0284 6FE0      		ldi r22,lo8(15)
 1131 0286 70E0      		ldi r23,0
 1132 0288 80E0      		ldi r24,0
 1133 028a 90E0      		ldi r25,0
 1134 028c 00C0      		rjmp 2f
 1135               		1:
 1136 028e 660F      		lsl r22
 1137 0290 771F      		rol r23
 1138 0292 881F      		rol r24
 1139 0294 991F      		rol r25
 1140               		2:
 1141 0296 4A95      		dec r20
 1142 0298 02F4      		brpl 1b
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1143               		.loc 1 440 104 discriminator 1 view .LVU289
 1144 029a 6095      		com r22
 1145 029c 7095      		com r23
 1146 029e 8095      		com r24
 1147 02a0 9095      		com r25
 1148               	.L73:
 1149               	.LVL108:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1150               		.loc 1 441 21 is_stmt 1 discriminator 4 view .LVU290
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1151               		.loc 1 441 47 is_stmt 0 discriminator 4 view .LVU291
 1152 02a2 C695      		lsr r28
 1153 02a4 C695      		lsr r28
 1154               	.LVL109:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1155               		.loc 1 441 47 discriminator 4 view .LVU292
 1156 02a6 C370      		andi r28,lo8(3)
 1157 02a8 602B      		or r22,r16
 1158               	.LVL110:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1159               		.loc 1 441 47 discriminator 4 view .LVU293
 1160 02aa 712B      		or r23,r17
 1161 02ac 822B      		or r24,r18
 1162 02ae 932B      		or r25,r19
 1163 02b0 C230      		cpi r28,lo8(2)
 1164 02b2 01F0      		breq .L74
 1165 02b4 00F4      		brsh .L75
 1166 02b6 C130      		cpi r28,lo8(1)
 1167 02b8 01F0      		breq .L76
 443:tmk_core/common/action.c ****                             break;
 1168               		.loc 1 443 29 is_stmt 1 view .LVU294
 1169 02ba 0E94 0000 		call layer_and
 1170               	.LVL111:
 444:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1171               		.loc 1 444 29 view .LVU295
 1172 02be 00C0      		rjmp .L32
 1173               	.L76:
 446:tmk_core/common/action.c ****                             break;
 1174               		.loc 1 446 29 view .LVU296
 1175 02c0 0E94 0000 		call layer_or
 1176               	.LVL112:
 447:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1177               		.loc 1 447 29 view .LVU297
 1178 02c4 00C0      		rjmp .L32
 1179               	.L74:
 449:tmk_core/common/action.c ****                             break;
 1180               		.loc 1 449 29 view .LVU298
 1181 02c6 0E94 0000 		call layer_xor
 1182               	.LVL113:
 450:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1183               		.loc 1 450 29 view .LVU299
 1184 02ca 00C0      		rjmp .L32
 1185               	.L75:
 452:tmk_core/common/action.c ****                             break;
 1186               		.loc 1 452 29 view .LVU300
 1187 02cc 0E94 0000 		call layer_state_set
 1188               	.LVL114:
 453:tmk_core/common/action.c ****                     }
 1189               		.loc 1 453 29 view .LVU301
 1190 02d0 00C0      		rjmp .L32
 1191               	.LVL115:
 1192               	.L37:
 453:tmk_core/common/action.c ****                     }
 1193               		.loc 1 453 29 is_stmt 0 view .LVU302
 1194               	.LBE35:
 459:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1195               		.loc 1 459 13 is_stmt 1 view .LVU303
 1196 02d2 CF70      		andi r28,lo8(15)
 1197               	.LVL116:
 459:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1198               		.loc 1 459 16 is_stmt 0 view .LVU304
 1199 02d4 0023      		tst r16
 1200 02d6 01F0      		breq .L77
 460:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1201               		.loc 1 460 17 is_stmt 1 view .LVU305
 1202 02d8 8C2F      		mov r24,r28
 1203 02da 0E94 0000 		call layer_on
 1204               	.LVL117:
 461:tmk_core/common/action.c ****             } else {
 1205               		.loc 1 461 17 view .LVU306
 1206 02de 8D2F      		mov r24,r29
 1207 02e0 00C0      		rjmp .L128
 1208               	.L77:
 463:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1209               		.loc 1 463 17 view .LVU307
 1210 02e2 8D2F      		mov r24,r29
 1211 02e4 0E94 0000 		call unregister_mods
 1212               	.LVL118:
 464:tmk_core/common/action.c ****             }
 1213               		.loc 1 464 17 view .LVU308
 1214 02e8 8C2F      		mov r24,r28
 1215               	.LVL119:
 1216               	.L126:
 551:tmk_core/common/action.c ****                         }
 1217               		.loc 1 551 29 is_stmt 0 view .LVU309
 1218 02ea 0E94 0000 		call layer_off
 1219               	.LVL120:
 1220 02ee 00C0      		rjmp .L32
 1221               	.L36:
 470:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1222               		.loc 1 470 13 is_stmt 1 view .LVU310
 1223 02f0 D23F      		cpi r29,lo8(-14)
 1224 02f2 01F0      		breq .L78
 1225 02f4 00F4      		brsh .L79
 1226 02f6 D03F      		cpi r29,lo8(-16)
 1227 02f8 01F0      		breq .L80
 1228 02fa D13F      		cpi r29,lo8(-15)
 1229 02fc 01F0      		breq .L81
 1230               	.L82:
 532:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1231               		.loc 1 532 21 view .LVU311
 532:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1232               		.loc 1 532 24 is_stmt 0 view .LVU312
 1233 02fe 0023      		tst r16
 1234 0300 01F4      		brne .+2
 1235 0302 00C0      		rjmp .L91
 533:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1236               		.loc 1 533 25 is_stmt 1 view .LVU313
 533:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1237               		.loc 1 533 28 is_stmt 0 view .LVU314
 1238 0304 1111      		cpse r17,__zero_reg__
 1239 0306 00C0      		rjmp .L129
 537:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1240               		.loc 1 537 76 is_stmt 1 view .LVU315
 538:tmk_core/common/action.c ****                         }
 1241               		.loc 1 538 29 view .LVU316
 1242 0308 8C2F      		mov r24,r28
 1243 030a 8F71      		andi r24,lo8(31)
 1244 030c 00C0      		rjmp .L127
 1245               	.L79:
 1246 030e D33F      		cpi r29,lo8(-13)
 1247 0310 01F0      		breq .L83
 1248 0312 D43F      		cpi r29,lo8(-12)
 1249 0314 01F4      		brne .L82
 518:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1250               		.loc 1 518 21 view .LVU317
 518:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1251               		.loc 1 518 24 is_stmt 0 view .LVU318
 1252 0316 0023      		tst r16
 1253 0318 01F0      		breq .L90
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1254               		.loc 1 519 25 is_stmt 1 view .LVU319
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1255               		.loc 1 519 50 is_stmt 0 view .LVU320
 1256 031a CF71      		andi r28,lo8(31)
 1257               	.LVL121:
 519:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1258               		.loc 1 519 25 view .LVU321
 1259 031c 8C2F      		mov r24,r28
 1260 031e 0E94 0000 		call layer_on
 1261               	.LVL122:
 520:tmk_core/common/action.c ****                     } else {
 1262               		.loc 1 520 25 is_stmt 1 view .LVU322
 1263 0322 63E0      		ldi r22,lo8(3)
 1264 0324 8C2F      		mov r24,r28
 1265 0326 0E94 0000 		call set_oneshot_layer
 1266               	.LVL123:
 1267 032a 00C0      		rjmp .L32
 1268               	.LVL124:
 1269               	.L80:
 473:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1270               		.loc 1 473 21 view .LVU323
 473:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1271               		.loc 1 473 24 is_stmt 0 view .LVU324
 1272 032c 0023      		tst r16
 1273 032e 01F0      		breq .L85
 474:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1274               		.loc 1 474 25 is_stmt 1 view .LVU325
 474:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1275               		.loc 1 474 28 is_stmt 0 view .LVU326
 1276 0330 1530      		cpi r17,lo8(5)
 1277 0332 00F0      		brlo .+2
 1278 0334 00C0      		rjmp .L32
 1279               	.L86:
 475:tmk_core/common/action.c ****                         }
 1280               		.loc 1 475 29 is_stmt 1 view .LVU327
 1281 0336 8C2F      		mov r24,r28
 1282 0338 8F71      		andi r24,lo8(31)
 1283 033a 0E94 0000 		call layer_invert
 1284               	.LVL125:
 1285 033e 00C0      		rjmp .L32
 1286               	.L85:
 478:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1287               		.loc 1 478 25 view .LVU328
 478:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1288               		.loc 1 478 28 is_stmt 0 view .LVU329
 1289 0340 1630      		cpi r17,lo8(6)
 1290 0342 00F0      		brlo .+2
 1291 0344 00C0      		rjmp .L32
 1292 0346 00C0      		rjmp .L86
 1293               	.L81:
 484:tmk_core/common/action.c ****                     break;
 1294               		.loc 1 484 21 is_stmt 1 view .LVU330
 1295 0348 8C2F      		mov r24,r28
 1296 034a 8F71      		andi r24,lo8(31)
 484:tmk_core/common/action.c ****                     break;
 1297               		.loc 1 484 68 is_stmt 0 view .LVU331
 1298 034c 0023      		tst r16
 1299 034e 01F0      		breq .L126
 1300               	.L127:
 538:tmk_core/common/action.c ****                         }
 1301               		.loc 1 538 29 view .LVU332
 1302 0350 0E94 0000 		call layer_on
 1303               	.LVL126:
 1304 0354 00C0      		rjmp .L32
 1305               	.L78:
 487:tmk_core/common/action.c ****                     break;
 1306               		.loc 1 487 21 is_stmt 1 view .LVU333
 1307 0356 8C2F      		mov r24,r28
 1308 0358 8F71      		andi r24,lo8(31)
 487:tmk_core/common/action.c ****                     break;
 1309               		.loc 1 487 69 is_stmt 0 view .LVU334
 1310 035a 0023      		tst r16
 1311 035c 01F0      		breq .L127
 1312 035e 00C0      		rjmp .L126
 1313               	.L83:
 490:tmk_core/common/action.c ****                     break;
 1314               		.loc 1 490 21 is_stmt 1 view .LVU335
 490:tmk_core/common/action.c ****                     break;
 1315               		.loc 1 490 70 is_stmt 0 view .LVU336
 1316 0360 0023      		tst r16
 1317 0362 01F0      		breq .L89
 490:tmk_core/common/action.c ****                     break;
 1318               		.loc 1 490 37 discriminator 1 view .LVU337
 1319 0364 8C2F      		mov r24,r28
 1320 0366 8F71      		andi r24,lo8(31)
 1321 0368 0E94 0000 		call layer_move
 1322               	.LVL127:
 1323 036c 00C0      		rjmp .L32
 1324               	.L89:
 490:tmk_core/common/action.c ****                     break;
 1325               		.loc 1 490 72 discriminator 2 view .LVU338
 1326 036e 0E94 0000 		call layer_clear
 1327               	.LVL128:
 1328 0372 00C0      		rjmp .L32
 1329               	.L90:
 522:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1330               		.loc 1 522 25 is_stmt 1 view .LVU339
 1331 0374 81E0      		ldi r24,lo8(1)
 1332 0376 0E94 0000 		call clear_oneshot_layer_state
 1333               	.LVL129:
 523:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1334               		.loc 1 523 25 view .LVU340
 523:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1335               		.loc 1 523 28 is_stmt 0 view .LVU341
 1336 037a 1230      		cpi r17,lo8(2)
 1337 037c 00F4      		brsh .+2
 1338 037e 00C0      		rjmp .L32
 524:tmk_core/common/action.c ****                         }
 1339               		.loc 1 524 29 is_stmt 1 view .LVU342
 1340 0380 82E0      		ldi r24,lo8(2)
 1341 0382 0E94 0000 		call clear_oneshot_layer_state
 1342               	.LVL130:
 1343 0386 00C0      		rjmp .L32
 1344               	.L91:
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1345               		.loc 1 541 25 view .LVU343
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1346               		.loc 1 541 28 is_stmt 0 view .LVU344
 1347 0388 1123      		tst r17
 1348 038a 01F0      		breq .L93
 542:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1349               		.loc 1 542 77 is_stmt 1 view .LVU345
 543:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1350               		.loc 1 543 29 view .LVU346
 543:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1351               		.loc 1 543 32 is_stmt 0 view .LVU347
 1352 038c D933      		cpi r29,lo8(57)
 1353 038e 01F0      		breq .+2
 1354 0390 00C0      		rjmp .L95
 544:tmk_core/common/action.c ****                             } else {
 1355               		.loc 1 544 33 is_stmt 1 view .LVU348
 1356               	.LVL131:
 1357               	.LBB36:
 1358               	.LBI31:
 166:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1359               		.loc 3 166 1 view .LVU349
 1360               	.LBB33:
 168:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1361               		.loc 3 168 2 view .LVU350
 172:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1362               		.loc 3 172 2 view .LVU351
 173:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1363               		.loc 3 173 2 view .LVU352
 174:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1364               		.loc 3 174 2 view .LVU353
 184:c:\users\nonej\documents\keyboard\msys64\home\nonej\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1365               		.loc 3 184 3 view .LVU354
 1366               		.loc 3 187 2 view .LVU355
 1367 0392 8FEF      		ldi r24,lo8(255999)
 1368 0394 97EE      		ldi r25,hi8(255999)
 1369 0396 E3E0      		ldi r30,hlo8(255999)
 1370 0398 8150      	1:	subi r24,1
 1371 039a 9040      		sbci r25,0
 1372 039c E040      		sbci r30,0
 1373 039e 01F4      		brne 1b
 1374 03a0 00C0      		rjmp .L131
 1375               	.LVL132:
 1376               	.L93:
 1377               		.loc 3 187 2 is_stmt 0 view .LVU356
 1378               	.LBE33:
 1379               	.LBE36:
 550:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1380               		.loc 1 550 79 is_stmt 1 view .LVU357
 551:tmk_core/common/action.c ****                         }
 1381               		.loc 1 551 29 view .LVU358
 1382 03a2 8C2F      		mov r24,r28
 1383 03a4 8F71      		andi r24,lo8(31)
 1384 03a6 00C0      		rjmp .L126
 1385               	.L35:
 562:tmk_core/common/action.c ****             break;
 1386               		.loc 1 562 13 view .LVU359
 562:tmk_core/common/action.c ****             break;
 1387               		.loc 1 562 83 is_stmt 0 view .LVU360
 1388 03a8 4C2F      		mov r20,r28
 1389 03aa 4F70      		andi r20,lo8(15)
 562:tmk_core/common/action.c ****             break;
 1390               		.loc 1 562 13 view .LVU361
 1391 03ac 6D2F      		mov r22,r29
 1392 03ae C601      		movw r24,r12
 1393 03b0 0E94 0000 		call action_get_macro
 1394               	.LVL133:
 1395 03b4 0E94 0000 		call action_macro_play
 1396               	.LVL134:
 563:tmk_core/common/action.c **** #endif
 1397               		.loc 1 563 13 is_stmt 1 view .LVU362
 1398 03b8 00C0      		rjmp .L32
 1399               	.L33:
 658:tmk_core/common/action.c ****             break;
 1400               		.loc 1 658 13 view .LVU363
 658:tmk_core/common/action.c ****             break;
 1401               		.loc 1 658 64 is_stmt 0 view .LVU364
 1402 03ba 4C2F      		mov r20,r28
 1403 03bc 4F70      		andi r20,lo8(15)
 658:tmk_core/common/action.c ****             break;
 1404               		.loc 1 658 13 view .LVU365
 1405 03be 6D2F      		mov r22,r29
 1406 03c0 C601      		movw r24,r12
 1407 03c2 0E94 0000 		call action_function
 1408               	.LVL135:
 659:tmk_core/common/action.c **** #endif
 1409               		.loc 1 659 13 is_stmt 1 view .LVU366
 1410 03c6 00C0      		rjmp .L32
 1411               	.LVL136:
 1412               	.L29:
 1413               	/* epilogue start */
 716:tmk_core/common/action.c **** 
 1414               		.loc 1 716 1 is_stmt 0 view .LVU367
 1415 03c8 DF91      		pop r29
 1416               	.LVL137:
 716:tmk_core/common/action.c **** 
 1417               		.loc 1 716 1 view .LVU368
 1418 03ca CF91      		pop r28
 716:tmk_core/common/action.c **** 
 1419               		.loc 1 716 1 view .LVU369
 1420 03cc 1F91      		pop r17
 1421 03ce 0F91      		pop r16
 1422 03d0 FF90      		pop r15
 1423 03d2 EF90      		pop r14
 1424               	.LVL138:
 716:tmk_core/common/action.c **** 
 1425               		.loc 1 716 1 view .LVU370
 1426 03d4 DF90      		pop r13
 1427 03d6 CF90      		pop r12
 1428               	.LVL139:
 716:tmk_core/common/action.c **** 
 1429               		.loc 1 716 1 view .LVU371
 1430 03d8 BF90      		pop r11
 1431 03da 0895      		ret
 1432               		.cfi_endproc
 1433               	.LFE113:
 1435               		.section	.text.process_record,"ax",@progbits
 1436               	.global	process_record
 1438               	process_record:
 1439               	.LVL140:
 1440               	.LFB112:
 181:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1441               		.loc 1 181 42 is_stmt 1 view -0
 1442               		.cfi_startproc
 181:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1443               		.loc 1 181 42 is_stmt 0 view .LVU373
 1444 0000 0F93      		push r16
 1445               	.LCFI14:
 1446               		.cfi_def_cfa_offset 3
 1447               		.cfi_offset 16, -2
 1448 0002 1F93      		push r17
 1449               	.LCFI15:
 1450               		.cfi_def_cfa_offset 4
 1451               		.cfi_offset 17, -3
 1452 0004 CF93      		push r28
 1453               	.LCFI16:
 1454               		.cfi_def_cfa_offset 5
 1455               		.cfi_offset 28, -4
 1456 0006 DF93      		push r29
 1457               	.LCFI17:
 1458               		.cfi_def_cfa_offset 6
 1459               		.cfi_offset 29, -5
 1460               	/* prologue: function */
 1461               	/* frame size = 0 */
 1462               	/* stack size = 4 */
 1463               	.L__stack_usage = 4
 1464 0008 EC01      		movw r28,r24
 182:tmk_core/common/action.c ****         return;
 1465               		.loc 1 182 5 is_stmt 1 view .LVU374
 1466               	.LBB39:
 1467               	.LBI39:
 1468               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1469               		.loc 4 48 20 view .LVU375
 1470               	.LBB40:
 1471               		.loc 4 48 51 view .LVU376
 1472               		.loc 4 48 74 is_stmt 0 view .LVU377
 1473 000a 8B81      		ldd r24,Y+3
 1474 000c 9C81      		ldd r25,Y+4
 1475               	.LVL141:
 1476               		.loc 4 48 74 view .LVU378
 1477 000e 892B      		or r24,r25
 1478 0010 01F0      		breq .L132
 1479 0012 8881      		ld r24,Y
 1480 0014 9981      		ldd r25,Y+1
 1481 0016 8923      		and r24,r25
 1482 0018 8F3F      		cpi r24,lo8(-1)
 1483 001a 01F4      		brne .L142
 1484               	.L132:
 1485               	/* epilogue start */
 1486               	.LBE40:
 1487               	.LBE39:
 200:tmk_core/common/action.c **** 
 1488               		.loc 1 200 1 view .LVU379
 1489 001c DF91      		pop r29
 1490 001e CF91      		pop r28
 1491               	.LVL142:
 200:tmk_core/common/action.c **** 
 1492               		.loc 1 200 1 view .LVU380
 1493 0020 1F91      		pop r17
 1494 0022 0F91      		pop r16
 1495 0024 0895      		ret
 1496               	.LVL143:
 1497               	.L142:
 186:tmk_core/common/action.c **** 
 1498               		.loc 1 186 5 is_stmt 1 view .LVU381
 186:tmk_core/common/action.c **** 
 1499               		.loc 1 186 10 is_stmt 0 view .LVU382
 1500 0026 CE01      		movw r24,r28
 1501 0028 0E94 0000 		call process_record_quantum
 1502               	.LVL144:
 186:tmk_core/common/action.c **** 
 1503               		.loc 1 186 8 view .LVU383
 1504 002c 8823      		tst r24
 1505 002e 01F0      		breq .L132
 188:tmk_core/common/action.c ****     dprint("ACTION: ");
 1506               		.loc 1 188 5 is_stmt 1 view .LVU384
 188:tmk_core/common/action.c ****     dprint("ACTION: ");
 1507               		.loc 1 188 23 is_stmt 0 view .LVU385
 1508 0030 6881      		ld r22,Y
 1509 0032 7981      		ldd r23,Y+1
 1510 0034 8A81      		ldd r24,Y+2
 1511 0036 0E94 0000 		call store_or_get_action
 1512               	.LVL145:
 1513 003a 8C01      		movw r16,r24
 1514               	.LVL146:
 189:tmk_core/common/action.c ****     debug_action(action);
 1515               		.loc 1 189 23 is_stmt 1 view .LVU386
 190:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1516               		.loc 1 190 5 view .LVU387
 192:tmk_core/common/action.c ****     layer_debug();
 1517               		.loc 1 192 29 view .LVU388
 193:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1518               		.loc 1 193 5 view .LVU389
 1519 003c 0E94 0000 		call layer_debug
 1520               	.LVL147:
 194:tmk_core/common/action.c ****     default_layer_debug();
 1521               		.loc 1 194 37 view .LVU390
 195:tmk_core/common/action.c **** #endif
 1522               		.loc 1 195 5 view .LVU391
 1523 0040 0E94 0000 		call default_layer_debug
 1524               	.LVL148:
 197:tmk_core/common/action.c **** 
 1525               		.loc 1 197 15 view .LVU392
 199:tmk_core/common/action.c **** }
 1526               		.loc 1 199 5 view .LVU393
 199:tmk_core/common/action.c **** }
 1527               		.loc 1 199 5 is_stmt 0 view .LVU394
 1528 0044 B801      		movw r22,r16
 1529 0046 CE01      		movw r24,r28
 1530               	/* epilogue start */
 200:tmk_core/common/action.c **** 
 1531               		.loc 1 200 1 view .LVU395
 1532 0048 DF91      		pop r29
 1533 004a CF91      		pop r28
 1534               	.LVL149:
 200:tmk_core/common/action.c **** 
 1535               		.loc 1 200 1 view .LVU396
 1536 004c 1F91      		pop r17
 1537 004e 0F91      		pop r16
 1538               	.LVL150:
 199:tmk_core/common/action.c **** }
 1539               		.loc 1 199 5 view .LVU397
 1540 0050 0C94 0000 		jmp process_action
 1541               	.LVL151:
 199:tmk_core/common/action.c **** }
 1542               		.loc 1 199 5 view .LVU398
 1543               		.cfi_endproc
 1544               	.LFE112:
 1546               		.section	.text.process_record_nocache,"ax",@progbits
 1547               	.global	process_record_nocache
 1549               	process_record_nocache:
 1550               	.LVL152:
 1551               	.LFB109:
 143:tmk_core/common/action.c ****     disable_action_cache = true;
 1552               		.loc 1 143 50 is_stmt 1 view -0
 1553               		.cfi_startproc
 1554               	/* prologue: function */
 1555               	/* frame size = 0 */
 1556               	/* stack size = 0 */
 1557               	.L__stack_usage = 0
 144:tmk_core/common/action.c ****     process_record(record);
 1558               		.loc 1 144 5 view .LVU400
 144:tmk_core/common/action.c ****     process_record(record);
 1559               		.loc 1 144 26 is_stmt 0 view .LVU401
 1560 0000 21E0      		ldi r18,lo8(1)
 1561 0002 2093 0000 		sts disable_action_cache,r18
 145:tmk_core/common/action.c ****     disable_action_cache = false;
 1562               		.loc 1 145 5 is_stmt 1 view .LVU402
 1563 0006 0E94 0000 		call process_record
 1564               	.LVL153:
 146:tmk_core/common/action.c **** }
 1565               		.loc 1 146 5 view .LVU403
 146:tmk_core/common/action.c **** }
 1566               		.loc 1 146 26 is_stmt 0 view .LVU404
 1567 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1568               	/* epilogue start */
 147:tmk_core/common/action.c **** #else
 1569               		.loc 1 147 1 view .LVU405
 1570 000e 0895      		ret
 1571               		.cfi_endproc
 1572               	.LFE109:
 1574               		.section	.text.register_weak_mods,"ax",@progbits
 1575               	.global	register_weak_mods
 1577               	register_weak_mods:
 1578               	.LVL154:
 1579               	.LFB119:
 905:tmk_core/common/action.c **** 
 906:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 907:tmk_core/common/action.c ****  *
 908:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 909:tmk_core/common/action.c ****  */
 910:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1580               		.loc 1 910 39 is_stmt 1 view -0
 1581               		.cfi_startproc
 1582               	/* prologue: function */
 1583               	/* frame size = 0 */
 1584               	/* stack size = 0 */
 1585               	.L__stack_usage = 0
 911:tmk_core/common/action.c ****     if (mods) {
 1586               		.loc 1 911 5 view .LVU407
 1587               		.loc 1 911 8 is_stmt 0 view .LVU408
 1588 0000 8823      		tst r24
 1589 0002 01F0      		breq .L144
 912:tmk_core/common/action.c ****         add_weak_mods(mods);
 1590               		.loc 1 912 9 is_stmt 1 view .LVU409
 1591 0004 0E94 0000 		call add_weak_mods
 1592               	.LVL155:
 913:tmk_core/common/action.c ****         send_keyboard_report();
 1593               		.loc 1 913 9 view .LVU410
 1594 0008 0C94 0000 		jmp send_keyboard_report
 1595               	.LVL156:
 1596               	.L144:
 1597               	/* epilogue start */
 914:tmk_core/common/action.c ****     }
 915:tmk_core/common/action.c **** }
 1598               		.loc 1 915 1 is_stmt 0 view .LVU411
 1599 000c 0895      		ret
 1600               		.cfi_endproc
 1601               	.LFE119:
 1603               		.section	.text.unregister_weak_mods,"ax",@progbits
 1604               	.global	unregister_weak_mods
 1606               	unregister_weak_mods:
 1607               	.LVL157:
 1608               	.LFB120:
 916:tmk_core/common/action.c **** 
 917:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 918:tmk_core/common/action.c ****  *
 919:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 920:tmk_core/common/action.c ****  */
 921:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1609               		.loc 1 921 41 is_stmt 1 view -0
 1610               		.cfi_startproc
 1611               	/* prologue: function */
 1612               	/* frame size = 0 */
 1613               	/* stack size = 0 */
 1614               	.L__stack_usage = 0
 922:tmk_core/common/action.c ****     if (mods) {
 1615               		.loc 1 922 5 view .LVU413
 1616               		.loc 1 922 8 is_stmt 0 view .LVU414
 1617 0000 8823      		tst r24
 1618 0002 01F0      		breq .L146
 923:tmk_core/common/action.c ****         del_weak_mods(mods);
 1619               		.loc 1 923 9 is_stmt 1 view .LVU415
 1620 0004 0E94 0000 		call del_weak_mods
 1621               	.LVL158:
 924:tmk_core/common/action.c ****         send_keyboard_report();
 1622               		.loc 1 924 9 view .LVU416
 1623 0008 0C94 0000 		jmp send_keyboard_report
 1624               	.LVL159:
 1625               	.L146:
 1626               	/* epilogue start */
 925:tmk_core/common/action.c ****     }
 926:tmk_core/common/action.c **** }
 1627               		.loc 1 926 1 is_stmt 0 view .LVU417
 1628 000c 0895      		ret
 1629               		.cfi_endproc
 1630               	.LFE120:
 1632               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1633               	.global	clear_keyboard_but_mods_and_keys
 1635               	clear_keyboard_but_mods_and_keys:
 1636               	.LFB123:
 927:tmk_core/common/action.c **** 
 928:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 929:tmk_core/common/action.c ****  *
 930:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 931:tmk_core/common/action.c ****  */
 932:tmk_core/common/action.c **** void clear_keyboard(void) {
 933:tmk_core/common/action.c ****     clear_mods();
 934:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 935:tmk_core/common/action.c **** }
 936:tmk_core/common/action.c **** 
 937:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 938:tmk_core/common/action.c ****  *
 939:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 940:tmk_core/common/action.c ****  */
 941:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 942:tmk_core/common/action.c ****     clear_keys();
 943:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 944:tmk_core/common/action.c **** }
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1637               		.loc 1 950 41 is_stmt 1 view -0
 1638               		.cfi_startproc
 1639               	/* prologue: function */
 1640               	/* frame size = 0 */
 1641               	/* stack size = 0 */
 1642               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     clear_weak_mods();
 1643               		.loc 1 951 5 view .LVU419
 1644 0000 0E94 0000 		call clear_weak_mods
 1645               	.LVL160:
 952:tmk_core/common/action.c ****     clear_macro_mods();
 1646               		.loc 1 952 5 view .LVU420
 1647 0004 0E94 0000 		call clear_macro_mods
 1648               	.LVL161:
 953:tmk_core/common/action.c ****     send_keyboard_report();
 1649               		.loc 1 953 5 view .LVU421
 1650 0008 0C94 0000 		jmp send_keyboard_report
 1651               	.LVL162:
 1652               		.cfi_endproc
 1653               	.LFE123:
 1655               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1656               	.global	clear_keyboard_but_mods
 1658               	clear_keyboard_but_mods:
 1659               	.LFB122:
 941:tmk_core/common/action.c ****     clear_keys();
 1660               		.loc 1 941 36 view -0
 1661               		.cfi_startproc
 1662               	/* prologue: function */
 1663               	/* frame size = 0 */
 1664               	/* stack size = 0 */
 1665               	.L__stack_usage = 0
 942:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1666               		.loc 1 942 5 view .LVU423
 1667 0000 0E94 0000 		call clear_keys
 1668               	.LVL163:
 943:tmk_core/common/action.c **** }
 1669               		.loc 1 943 5 view .LVU424
 1670 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1671               	.LVL164:
 1672               		.cfi_endproc
 1673               	.LFE122:
 1675               		.section	.text.clear_keyboard,"ax",@progbits
 1676               	.global	clear_keyboard
 1678               	clear_keyboard:
 1679               	.LFB121:
 932:tmk_core/common/action.c ****     clear_mods();
 1680               		.loc 1 932 27 view -0
 1681               		.cfi_startproc
 1682               	/* prologue: function */
 1683               	/* frame size = 0 */
 1684               	/* stack size = 0 */
 1685               	.L__stack_usage = 0
 933:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1686               		.loc 1 933 5 view .LVU426
 1687 0000 0E94 0000 		call clear_mods
 1688               	.LVL165:
 934:tmk_core/common/action.c **** }
 1689               		.loc 1 934 5 view .LVU427
 1690 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1691               	.LVL166:
 1692               		.cfi_endproc
 1693               	.LFE121:
 1695               		.section	.text.is_tap_action,"ax",@progbits
 1696               	.global	is_tap_action
 1698               	is_tap_action:
 1699               	.LVL167:
 1700               	.LFB125:
 954:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 955:tmk_core/common/action.c ****     mousekey_clear();
 956:tmk_core/common/action.c ****     mousekey_send();
 957:tmk_core/common/action.c **** #endif
 958:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 959:tmk_core/common/action.c ****     host_system_send(0);
 960:tmk_core/common/action.c ****     host_consumer_send(0);
 961:tmk_core/common/action.c **** #endif
 962:tmk_core/common/action.c **** }
 963:tmk_core/common/action.c **** 
 964:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 965:tmk_core/common/action.c ****  *
 966:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 967:tmk_core/common/action.c ****  */
 968:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 969:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 970:tmk_core/common/action.c ****     return is_tap_action(action);
 971:tmk_core/common/action.c **** }
 972:tmk_core/common/action.c **** 
 973:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 974:tmk_core/common/action.c ****  *
 975:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 976:tmk_core/common/action.c ****  */
 977:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1701               		.loc 1 977 37 view -0
 1702               		.cfi_startproc
 1703               	/* prologue: function */
 1704               	/* frame size = 0 */
 1705               	/* stack size = 0 */
 1706               	.L__stack_usage = 0
 978:tmk_core/common/action.c ****     switch (action.kind.id) {
 1707               		.loc 1 978 5 view .LVU429
 1708               		.loc 1 978 24 is_stmt 0 view .LVU430
 1709 0000 E92F      		mov r30,r25
 1710 0002 E295      		swap r30
 1711 0004 EF70      		andi r30,lo8(15)
 1712               		.loc 1 978 5 view .LVU431
 1713 0006 E250      		subi r30,lo8(-(-2))
 1714 0008 EE30      		cpi r30,lo8(14)
 1715 000a 00F4      		brsh .L160
 1716 000c F0E0      		ldi r31,0
 1717 000e E050      		subi r30,lo8(-(gs(.L154)))
 1718 0010 F040      		sbci r31,hi8(-(gs(.L154)))
 1719 0012 0C94 0000 		jmp __tablejump2__
 1720               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1721               		.p2align	1
 1722               	.L154:
 1723 0000 0000      		.word gs(.L155)
 1724 0002 0000      		.word gs(.L155)
 1725 0004 0000      		.word gs(.L160)
 1726 0006 0000      		.word gs(.L160)
 1727 0008 0000      		.word gs(.L156)
 1728 000a 0000      		.word gs(.L160)
 1729 000c 0000      		.word gs(.L160)
 1730 000e 0000      		.word gs(.L160)
 1731 0010 0000      		.word gs(.L155)
 1732 0012 0000      		.word gs(.L155)
 1733 0014 0000      		.word gs(.L153)
 1734 0016 0000      		.word gs(.L160)
 1735 0018 0000      		.word gs(.L160)
 1736 001a 0000      		.word gs(.L153)
 1737               		.section	.text.is_tap_action
 1738               	.L155:
 979:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 980:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 981:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 982:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 983:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1739               		.loc 1 983 13 is_stmt 1 view .LVU432
 1740 0016 803F      		cpi r24,lo8(-16)
 1741 0018 01F0      		breq .L163
 1742 001a 00F4      		brsh .L157
 1743 001c 883E      		cpi r24,lo8(-24)
 1744 001e 00F4      		brsh .L160
 1745               	.L163:
 984:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 985:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 986:tmk_core/common/action.c ****                 case OP_ONESHOT:
 987:tmk_core/common/action.c ****                     return true;
 1746               		.loc 1 987 28 is_stmt 0 view .LVU433
 1747 0020 81E0      		ldi r24,lo8(1)
 1748               	.LVL168:
 1749               	/* epilogue start */
 988:tmk_core/common/action.c ****             }
 989:tmk_core/common/action.c ****             return false;
 990:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 991:tmk_core/common/action.c ****             switch (action.swap.code) {
 992:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 993:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 994:tmk_core/common/action.c ****                     return true;
 995:tmk_core/common/action.c ****             }
 996:tmk_core/common/action.c ****             return false;
 997:tmk_core/common/action.c ****         case ACT_MACRO:
 998:tmk_core/common/action.c ****         case ACT_FUNCTION:
 999:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1000:tmk_core/common/action.c ****                 return true;
1001:tmk_core/common/action.c ****             }
1002:tmk_core/common/action.c ****             return false;
1003:tmk_core/common/action.c ****     }
1004:tmk_core/common/action.c ****     return false;
1005:tmk_core/common/action.c **** }
 1750               		.loc 1 1005 1 view .LVU434
 1751 0022 0895      		ret
 1752               	.LVL169:
 1753               	.L157:
 1754               		.loc 1 1005 1 view .LVU435
 1755 0024 843F      		cpi r24,lo8(-12)
 1756 0026 01F0      		breq .L163
 1757               	.L160:
 989:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1758               		.loc 1 989 20 view .LVU436
 1759 0028 80E0      		ldi r24,0
 1760               	.LVL170:
 989:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1761               		.loc 1 989 20 view .LVU437
 1762 002a 0895      		ret
 1763               	.LVL171:
 1764               	.L156:
 991:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1765               		.loc 1 991 13 is_stmt 1 view .LVU438
 1766 002c 883E      		cpi r24,lo8(-24)
 1767 002e 00F0      		brlo .L163
 1768 0030 813F      		cpi r24,lo8(-15)
 1769 0032 01F4      		brne .L160
 1770 0034 00C0      		rjmp .L163
 1771               	.L153:
 999:tmk_core/common/action.c ****                 return true;
 1772               		.loc 1 999 13 view .LVU439
 999:tmk_core/common/action.c ****                 return true;
 1773               		.loc 1 999 16 is_stmt 0 view .LVU440
 1774 0036 93FB      		bst r25,3
 1775 0038 8827      		clr r24
 1776 003a 80F9      		bld r24,0
 1777               	.LVL172:
 999:tmk_core/common/action.c ****                 return true;
 1778               		.loc 1 999 16 view .LVU441
 1779 003c 0895      		ret
 1780               		.cfi_endproc
 1781               	.LFE125:
 1783               		.section	.text.is_tap_key,"ax",@progbits
 1784               	.global	is_tap_key
 1786               	is_tap_key:
 1787               	.LVL173:
 1788               	.LFB124:
 968:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1789               		.loc 1 968 31 is_stmt 1 view -0
 1790               		.cfi_startproc
 1791               	/* prologue: function */
 1792               	/* frame size = 0 */
 1793               	/* stack size = 0 */
 1794               	.L__stack_usage = 0
 969:tmk_core/common/action.c ****     return is_tap_action(action);
 1795               		.loc 1 969 5 view .LVU443
 969:tmk_core/common/action.c ****     return is_tap_action(action);
 1796               		.loc 1 969 23 is_stmt 0 view .LVU444
 1797 0000 0E94 0000 		call layer_switch_get_action
 1798               	.LVL174:
 970:tmk_core/common/action.c **** }
 1799               		.loc 1 970 5 is_stmt 1 view .LVU445
 970:tmk_core/common/action.c **** }
 1800               		.loc 1 970 12 is_stmt 0 view .LVU446
 1801 0004 0C94 0000 		jmp is_tap_action
 1802               	.LVL175:
 1803               		.cfi_endproc
 1804               	.LFE124:
 1806               		.section	.text.debug_event,"ax",@progbits
 1807               	.global	debug_event
 1809               	debug_event:
 1810               	.LFB126:
1006:tmk_core/common/action.c **** 
1007:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1008:tmk_core/common/action.c ****  *
1009:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1010:tmk_core/common/action.c ****  */
1011:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1811               		.loc 1 1011 36 is_stmt 1 view -0
 1812               		.cfi_startproc
 1813 0000 CF93      		push r28
 1814               	.LCFI18:
 1815               		.cfi_def_cfa_offset 3
 1816               		.cfi_offset 28, -2
 1817 0002 DF93      		push r29
 1818               	.LCFI19:
 1819               		.cfi_def_cfa_offset 4
 1820               		.cfi_offset 29, -3
 1821 0004 00D0      		rcall .
 1822 0006 00D0      		rcall .
 1823 0008 0F92      		push __tmp_reg__
 1824               	.LCFI20:
 1825               		.cfi_def_cfa_offset 9
 1826 000a CDB7      		in r28,__SP_L__
 1827 000c DEB7      		in r29,__SP_H__
 1828               	.LCFI21:
 1829               		.cfi_def_cfa_register 28
 1830               	/* prologue: function */
 1831               	/* frame size = 5 */
 1832               	/* stack size = 7 */
 1833               	.L__stack_usage = 7
 1834               		.loc 1 1011 138 view .LVU448
 1835               	/* epilogue start */
 1836               		.loc 1 1011 1 is_stmt 0 view .LVU449
 1837 000e 0F90      		pop __tmp_reg__
 1838 0010 0F90      		pop __tmp_reg__
 1839 0012 0F90      		pop __tmp_reg__
 1840 0014 0F90      		pop __tmp_reg__
 1841 0016 0F90      		pop __tmp_reg__
 1842 0018 DF91      		pop r29
 1843 001a CF91      		pop r28
 1844 001c 0895      		ret
 1845               		.cfi_endproc
 1846               	.LFE126:
 1848               		.section	.text.debug_record,"ax",@progbits
 1849               	.global	debug_record
 1851               	debug_record:
 1852               	.LFB127:
1012:tmk_core/common/action.c **** 
1013:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1014:tmk_core/common/action.c ****  *
1015:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1016:tmk_core/common/action.c ****  */
1017:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1853               		.loc 1 1017 39 is_stmt 1 view -0
 1854               		.cfi_startproc
 1855 0000 CF93      		push r28
 1856               	.LCFI22:
 1857               		.cfi_def_cfa_offset 3
 1858               		.cfi_offset 28, -2
 1859 0002 DF93      		push r29
 1860               	.LCFI23:
 1861               		.cfi_def_cfa_offset 4
 1862               		.cfi_offset 29, -3
 1863 0004 00D0      		rcall .
 1864 0006 00D0      		rcall .
 1865 0008 00D0      		rcall .
 1866               	.LCFI24:
 1867               		.cfi_def_cfa_offset 10
 1868 000a CDB7      		in r28,__SP_L__
 1869 000c DEB7      		in r29,__SP_H__
 1870               	.LCFI25:
 1871               		.cfi_def_cfa_register 28
 1872               	/* prologue: function */
 1873               	/* frame size = 6 */
 1874               	/* stack size = 8 */
 1875               	.L__stack_usage = 8
1018:tmk_core/common/action.c ****     debug_event(record.event);
 1876               		.loc 1 1018 5 view .LVU451
1019:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1020:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 1877               		.loc 1 1020 77 view .LVU452
 1878               	/* epilogue start */
1021:tmk_core/common/action.c **** #endif
1022:tmk_core/common/action.c **** }
 1879               		.loc 1 1022 1 is_stmt 0 view .LVU453
 1880 000e 2696      		adiw r28,6
 1881 0010 0FB6      		in __tmp_reg__,__SREG__
 1882 0012 F894      		cli
 1883 0014 DEBF      		out __SP_H__,r29
 1884 0016 0FBE      		out __SREG__,__tmp_reg__
 1885 0018 CDBF      		out __SP_L__,r28
 1886 001a DF91      		pop r29
 1887 001c CF91      		pop r28
 1888 001e 0895      		ret
 1889               		.cfi_endproc
 1890               	.LFE127:
 1892               		.section	.text.debug_action,"ax",@progbits
 1893               	.global	debug_action
 1895               	debug_action:
 1896               	.LVL176:
 1897               	.LFB128:
1023:tmk_core/common/action.c **** 
1024:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1025:tmk_core/common/action.c ****  *
1026:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1027:tmk_core/common/action.c ****  */
1028:tmk_core/common/action.c **** void debug_action(action_t action) {
 1898               		.loc 1 1028 36 is_stmt 1 view -0
 1899               		.cfi_startproc
 1900               	/* prologue: function */
 1901               	/* frame size = 0 */
 1902               	/* stack size = 0 */
 1903               	.L__stack_usage = 0
1029:tmk_core/common/action.c ****     switch (action.kind.id) {
 1904               		.loc 1 1029 5 view .LVU455
1030:tmk_core/common/action.c ****         case ACT_LMODS:
1031:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1032:tmk_core/common/action.c ****             break;
1033:tmk_core/common/action.c ****         case ACT_RMODS:
1034:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1035:tmk_core/common/action.c ****             break;
1036:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1037:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1038:tmk_core/common/action.c ****             break;
1039:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1040:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1041:tmk_core/common/action.c ****             break;
1042:tmk_core/common/action.c ****         case ACT_USAGE:
1043:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1044:tmk_core/common/action.c ****             break;
1045:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1046:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1047:tmk_core/common/action.c ****             break;
1048:tmk_core/common/action.c ****         case ACT_LAYER:
1049:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1050:tmk_core/common/action.c ****             break;
1051:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1052:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1053:tmk_core/common/action.c ****             break;
1054:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1055:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1056:tmk_core/common/action.c ****             break;
1057:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1058:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1059:tmk_core/common/action.c ****             break;
1060:tmk_core/common/action.c ****         case ACT_MACRO:
1061:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1062:tmk_core/common/action.c ****             break;
1063:tmk_core/common/action.c ****         case ACT_COMMAND:
1064:tmk_core/common/action.c ****             dprint("ACT_COMMAND");
1065:tmk_core/common/action.c ****             break;
1066:tmk_core/common/action.c ****         case ACT_FUNCTION:
1067:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1068:tmk_core/common/action.c ****             break;
1069:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1070:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1071:tmk_core/common/action.c ****             break;
1072:tmk_core/common/action.c ****         default:
1073:tmk_core/common/action.c ****             dprint("UNKNOWN");
1074:tmk_core/common/action.c ****             break;
1075:tmk_core/common/action.c ****     }
1076:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 1905               		.loc 1 1076 75 view .LVU456
 1906               	/* epilogue start */
1077:tmk_core/common/action.c **** }
 1907               		.loc 1 1077 1 is_stmt 0 view .LVU457
 1908 0000 0895      		ret
 1909               		.cfi_endproc
 1910               	.LFE128:
 1912               		.section	.rodata.CSWTCH.10,"a"
 1915               	CSWTCH.10:
 1916 0000 E200      		.word	226
 1917 0002 E900      		.word	233
 1918 0004 EA00      		.word	234
 1919 0006 B500      		.word	181
 1920 0008 B600      		.word	182
 1921 000a B700      		.word	183
 1922 000c CD00      		.word	205
 1923 000e 8301      		.word	387
 1924 0010 CC00      		.word	204
 1925 0012 8A01      		.word	394
 1926 0014 9201      		.word	402
 1927 0016 9401      		.word	404
 1928 0018 2102      		.word	545
 1929 001a 2302      		.word	547
 1930 001c 2402      		.word	548
 1931 001e 2502      		.word	549
 1932 0020 2602      		.word	550
 1933 0022 2702      		.word	551
 1934 0024 2A02      		.word	554
 1935 0026 B300      		.word	179
 1936 0028 B400      		.word	180
 1937 002a 6F00      		.word	111
 1938 002c 7000      		.word	112
 1939               		.section	.rodata.CSWTCH.9,"a"
 1942               	CSWTCH.9:
 1943 0000 81        		.byte	-127
 1944 0001 82        		.byte	-126
 1945 0002 83        		.byte	-125
 1946               	.global	disable_action_cache
 1947               		.section	.bss.disable_action_cache,"aw",@nobits
 1950               	disable_action_cache:
 1951 0000 00        		.zero	1
 1952               		.comm	tp_buttons,2,1
 1953               		.text
 1954               	.Letext0:
 1955               		.file 5 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchain
 1956               		.file 6 "tmk_core/common/keycode.h"
 1957               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 1958               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 1959               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 1960               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 1961               		.file 11 "c:\\users\\nonej\\documents\\keyboard\\msys64\\home\\nonej\\qmk_utils\\avr8-gnu-toolchai
 1962               		.file 12 "tmk_core/common/host.h"
 1963               		.file 13 "tmk_core/common/mousekey.h"
 1964               		.file 14 "tmk_core/common/command.h"
 1965               		.file 15 "tmk_core/common/action_code.h"
 1966               		.file 16 "tmk_core/common/action.h"
 1967               		.file 17 "tmk_core/common/action_layer.h"
 1968               		.file 18 "tmk_core/common/action_util.h"
 1969               		.file 19 "tmk_core/common/debug.h"
 1970               		.file 20 "tmk_core/common/led.h"
 1971               		.file 21 "tmk_core/common/action_macro.h"
 1972               		.file 22 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:2      *ABS*:0000003e __SP_H__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:3      *ABS*:0000003d __SP_L__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:4      *ABS*:0000003f __SREG__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:6      *ABS*:00000001 __zero_reg__
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:13     .text.action_exec:00000000 action_exec
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:94     .text.process_record_quantum:00000000 process_record_quantum
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:116    .text.process_record_tap_hint:00000000 process_record_tap_hint
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:141    .text.register_code:00000000 register_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1942   .rodata.CSWTCH.9:00000000 CSWTCH.9
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1915   .rodata.CSWTCH.10:00000000 CSWTCH.10
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:257    .text.unregister_code:00000000 unregister_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:347    .text.tap_code:00000000 tap_code
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:412    .text.register_mods:00000000 register_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:441    .text.unregister_mods:00000000 unregister_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:470    .text.process_action:00000000 process_action
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1438   .text.process_record:00000000 process_record
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1549   .text.process_record_nocache:00000000 process_record_nocache
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1950   .bss.disable_action_cache:00000000 disable_action_cache
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1577   .text.register_weak_mods:00000000 register_weak_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1606   .text.unregister_weak_mods:00000000 unregister_weak_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1635   .text.clear_keyboard_but_mods_and_keys:00000000 clear_keyboard_but_mods_and_keys
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1658   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1678   .text.clear_keyboard:00000000 clear_keyboard
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1698   .text.is_tap_action:00000000 is_tap_action
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1786   .text.is_tap_key:00000000 is_tap_key
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1809   .text.debug_event:00000000 debug_event
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1851   .text.debug_record:00000000 debug_record
C:\Users\nonej\Documents\Keyboard\msys64\tmp\cckmu1Ah.s:1895   .text.debug_action:00000000 debug_action
                            *COM*:00000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
add_key
send_keyboard_report
add_mods
host_system_send
host_consumer_send
del_key
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
