
/* TEMP
*	,-------------------------------------------------------------------------.
*	|     |     |     |     |     |     |     |     |     |     |     |       |
*	|-------------------------------------------------------------------------+
*	|      |     |     |     |     |     |     |     |     |     |     |      |
*	|-------------------------------------------------------------------------+
*	|       |     |     |     |     |     |     |     |     |     |     |     |
*	|-------------------------------------------------------------------------+
*	|     |     |     |     |      |     @     |      |     |     |     |     |
*	`-------------------------------------------------------------------------'


_________________
RGB layer_state




void persistent_default_layer_set(uint16_t default_layer) {
  eeconfig_update_default_layer(default_layer);
  default_layer_set(default_layer);
}

void matrix_init_user(void) {


  rgblight_enable();
}

void matrix_scan_user(void) {
  #ifdef RGBLIGHT_ENABLE

  static uint8_t old_layer = 255;
  uint8_t new_layer = biton32(layer_state);

  if (old_layer != new_layer) {
    switch (new_layer) {
      case _QW:
        rgblight_setrgb(RGB_MAGENTA);
        break;
      case _GM:
        rgblight_setrgb(RGB_AZURE);
        break;
      case _CH:
        rgblight_setrgb(RGB_RED);
        break;
      case _FN:
        rgblight_setrgb(RGB_SPRINGGREEN);
        break;
      case _TH:
        rgblight_setrgb(RGB_TURQUOISE);
        break;
    }

    old_layer = new_layer;
  }

  #endif //RGBLIGHT_ENABLE
}


________________________
	[_THUMB2] = LAYOUT(KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
		KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
		KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,
		KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_AT, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS),
*/

enum custom_keycodes {
  TD_TMP01, //tap dance
  M_GUIL0 = SAFE_RANGE, //macros
};



TAP DANCE
void td08_finished (qk_tap_dance_state_t *state, void *user_data); //(ref:TD_TMP01)
void td08_reset (qk_tap_dance_state_t *state, void *user_data);
int cur_dance (qk_tap_dance_state_t *state) {
  if (state->count == 1) {
    if (state->interrupted || !state->pressed) { return SINGLE_TAP; }
      else { return SINGLE_HOLD; }
  }
  if (state->count == 2) { return DOUBLE_SINGLE_TAP; }
  else { return 3; }
}
// (ref:TD_TMP01)

void td08_finished (qk_tap_dance_state_t *state, void *user_date) {
  td_state = cur_dance(state);
  switch (td_state) {
    case SINGLE_TAP:

      break;
    case SINGLE_HOLD:

      break;
    case DOUBLE_SINGLE_TAP:

  }
}
void td08_reset (qk_tap_dance_state_t *state, void *user_data) {
  switch (td_state) {
    case SINGLE_TAP:

      break;
    case SINGLE_HOLD:

      break;
    case DOUBLE_SINGLE_TAP:

  }
}

qk_tap_dance_action_t tap_dance_actions[] = {
  [TD_TMP01] = ACTION_TAP_DANCE_FN_ADVANCED_TIME(NULL, td08_finished, td08_reset, 160),
};
